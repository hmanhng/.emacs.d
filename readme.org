#+title: My Emacs Configuration
#+author: hmanhng
#+description: emacs literate config
#+startup: indent show2levels

* Content :TOC:
- [[#bootstrap][Bootstrap]]
  - [[#lexical-binding][Lexical binding]]
  - [[#var][Var]]
  - [[#lib][Lib]]
  - [[#package-manager][Package Manager]]
  - [[#fonts][Fonts]]
  - [[#theme][Theme]]
  - [[#startup-hook][Startup hook]]
  - [[#core][Core]]
- [[#packages][Packages]]
  - [[#evil-like-vim][Evil (Like vim)]]
  - [[#key-bindding][Key-Bindding]]
  - [[#ui][UI]]
  - [[#tools][Tools]]
  - [[#completion][Completion]]
  - [[#eglot][Eglot]]
  - [[#lang][Lang]]

* Bootstrap
** Lexical binding
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Lexical-Binding.html][Lexical Binding]]
#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
#+end_src

** Var
One of the things like using [[https://doomemacs.org/][Doom Emacs]] is that all non-versioned files (caches, worskapces, runtime data) went under `.local`.
Let's do the same and define `my/local-dir` that we'll use all across the board.
#+begin_src emacs-lisp
(defvar my/local-dir (concat my/emacs-dir ".local/") "Local state directory")
(defvar my/cache-dir (concat my/local-dir "cache/") "Cache state directory")
(setq user-emacs-directory my/cache-dir)
#+end_src

#+begin_src emacs-lisp
(defconst os/linux (eq system-type 'gnu/linux) "Non-nil on GNU/Linux systems.")
(defconst os/bsd (and (memq system-type '(berkeley-unix gnu/kfreebsd)) t) "Non-nil on BSD systems.")
(defconst os/win (and (memq system-type '(cygwin windows-nt ms-dos)) t) "Non-nil on Windows systems.")
(defconst os/mac (eq system-type 'darwin) "Non-nil on MacOS systems.")
#+end_src

** Lib
*** Keybinding Macro
#+begin_src emacs-lisp
;;; Keybinding macros
;;; =================

;; PERF+HACK: At some point, MinEmacs startup become too slow, specially when
;; initializing `general' and `evil'. After trying several configurations, I
;; figured out that deferring `general' solves the issue. However, deferring
;; `general' means that we cannot define the keybindings when loading other
;; packages, i.e. before `general' gets loaded and the MinEmacs definers (i.e.
;; `+minemacs--internal-map!', `+minemacs--internal-map-local!', ...) are made
;; available. We overcome this by defining these macros to define the
;; keybindings by wrapping the actual definition in a `with-eval-after-load'
;; block to be evaluated only after `general' gets loaded and configured and the
;; definers are ready (See `me-keybindings').
(defmacro +map! (&rest args)
  "A wrapper around `+minemacs--internal-map!'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (+leader-key! ,@args)))

(defmacro +map-local! (&rest args)
  "A wrapper around `+minemacs--internal-map-local!'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (+localleader-key! ,@args)))

;; Wrappers around `general's VIM like definers, needs `general-evil-setup' to
;; be executed (See `me-keybindings')
(defmacro +nmap! (&rest args)
  "A wrapper around `general-nmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-nmap ,@args)))

(defmacro +vmap! (&rest args)
  "A wrapper around `general-vmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-vmap ,@args)))

(defmacro +mmap! (&rest args)
  "A wrapper around `general-mmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-mmap ,@args)))

(defmacro +imap! (&rest args)
  "A wrapper around `general-imap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-imap ,@args)))

(defmacro +emap! (&rest args)
  "A wrapper around `general-emap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-emap ,@args)))

(defmacro +omap! (&rest args)
  "A wrapper around `general-omap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-omap ,@args)))

(defmacro +rmap! (&rest args)
  "A wrapper around `general-rmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-rmap ,@args)))

(defmacro +iemap! (&rest args)
  "A wrapper around `general-iemap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-iemap ,@args)))

(defmacro +nvmap! (&rest args)
  "A wrapper around `general-nvmap'.
It is deferred until `general' gets loaded and configured."
  (declare (indent defun))
  `(with-eval-after-load 'me-general-ready
    (general-nvmap ,@args)))
#+end_src

*** File, Dir
Files, directories and IO helper functions
#+begin_src emacs-lisp
(defun +file-mime-type (file)
  "Get MIME type for FILE based on magic codes provided by the \"file\" command.
Return a symbol of the MIME type, ex: `text/x-lisp', `text/plain',
`application/x-object', `application/octet-stream', etc."
  (if-let ((file-cmd (executable-find "file"))
           (mime-type (shell-command-to-string (format "%s --brief --mime-type %s" file-cmd file))))
      (intern (string-trim-right mime-type))
    (error "The \"file\" command isn't installed")))

(defun +file-name-incremental (filename)
  "Return a unique file name for FILENAME.
If \"file.ext\" exists, returns \"file-0.ext\"."
  (let* ((ext (file-name-extension filename))
         (dir (file-name-directory filename))
         (file (file-name-base filename))
         (filename-regex (concat "^" file "\\(?:-\\(?1:[[:digit:]]+\\)\\)?" (if ext (concat "\\." ext) "")))
         (last-file (car (last (directory-files dir nil filename-regex))))
         (last-file-num (and last-file (string-match filename-regex last-file) (match-string 1 last-file)))
         (num (1+ (string-to-number (or last-file-num "-1")))))
    (file-name-concat dir (format "%s%s%s" file (if last-file (format "-%d" num) "") (if ext (concat "." ext) "")))))

(defun +file-read-to-string (filename)
  "Return a string with the contents of FILENAME."
  (when (and (file-exists-p filename) (not (file-directory-p filename)))
    (with-temp-buffer
      (insert-file-contents filename)
      (buffer-string))))

(defun +directory-subdirs (dir)
  "Return a list of sub-directories in DIR."
  (when dir
    (seq-filter #'file-directory-p
                (mapcar #'abbreviate-file-name (directory-files dir t "[^.][^.]?\\'")))))

(defun +directory-ensure (&rest path-parts)
  "Concatenate PATH-PARTS to construct a path and return it.

Ensure the path exists, if not create it. The exact behavior is to create the
parent directory if the path is a file, and if the path is a directory, create
that directory."
  (let* ((path (mapconcat #'identity path-parts nil))
         (parent-dir (file-name-directory path)))
    (unless (file-directory-p parent-dir)
      (ignore-errors (mkdir parent-dir t))
      (unless (file-directory-p parent-dir)
        (+error! "Cannot create directory %s" parent-dir)))
    path))

(defun +delete-this-file (&optional path force-p)
  "Delete PATH.

If PATH is not specified, default to the current buffer's file.

If FORCE-P, delete without confirmation."
  (interactive
   (list (buffer-file-name (buffer-base-buffer))
         current-prefix-arg))
  (let* ((path (or path (buffer-file-name (buffer-base-buffer))))
         (short-path (abbreviate-file-name path)))
    (unless (and path (file-exists-p path))
      (user-error "Buffer is not visiting any file"))
    (unless (file-exists-p path)
      (error "File doesn't exist: %s" path))
    (unless (or force-p (y-or-n-p (format "Really delete %S?" short-path)))
      (user-error "Aborted"))
    (unwind-protect
        (progn (delete-file path delete-by-moving-to-trash) t)
      (when (file-exists-p path)
        (error "Failed to delete %S" short-path)))))

;; Rewrite of: crux-delete-file-and-buffer, proposes also to delete VC
;; controlled files even when `vc-delete-file' fails (edited, conflict, ...).
(defun +delete-this-file-and-buffer (&optional filename)
  "Delete FILENAME and its associated visiting buffer."
  (interactive)
  (when-let ((filename (or filename (buffer-file-name)))
             (short-path (abbreviate-file-name filename)))
    (if (vc-backend filename)
        (or (ignore-errors (vc-delete-file (buffer-file-name)))
            (+delete-this-file filename)
            (kill-buffer))
      (when (y-or-n-p (format "Are you sure you want to delete %s? " short-path))
        (delete-file filename delete-by-moving-to-trash)
        (message "Deleted file %s" short-path)
        (kill-buffer)))))

(defun +delete-file-or-directory (file-or-directory &optional trash recursive)
  "Delete FILE-OR-DIRECTORY with `delete-file' or `delete-directory'.

Move to trash when TRASH is non-nil, delete directories recursively when
RECURSIVE is non-nil."
  (if (file-directory-p file-or-directory)
      (delete-directory file-or-directory recursive trash)
    (delete-file file-or-directory trash)))

(if (fboundp 'rename-visited-file)
    (defalias '+move-this-file #'rename-visited-file)
  (defun +move-this-file (new-path &optional force-p)
    "Move current buffer's file to NEW-PATH.

If FORCE-P, overwrite the destination file if it exists, without confirmation."
    (interactive
     (list (read-file-name "Move file to: ")
           current-prefix-arg))
    (unless (and buffer-file-name (file-exists-p buffer-file-name))
      (user-error "Buffer is not visiting any file"))
    (let ((old-path (buffer-file-name (buffer-base-buffer)))
          (new-path (expand-file-name new-path)))
      (when (directory-name-p new-path)
        (setq new-path (expand-file-name (file-name-nondirectory old-path) new-path)))
      (make-directory (file-name-directory new-path) t)
      (rename-file old-path new-path (or force-p 1))
      (set-visited-file-name new-path t t)
      (message "File moved to %S" (abbreviate-file-name new-path)))))

(defun +tramp-sudo-file-path (file)
  "Construct a Tramp sudo path to FILE. Works for both local and remote files."
  (tramp-make-tramp-file-name "sudo" tramp-root-id-string nil (or (file-remote-p file 'host) "localhost") nil file))

(defun +sudo-find-file (file)
  "Open FILE as root."
  (interactive "FOpen file as root: ")
  (find-file (+tramp-sudo-file-path file)))

(defun +sudo-this-file ()
  "Open the current file as root."
  (interactive)
  (if-let ((this-file (or buffer-file-name
                          (when (derived-mode-p 'dired-mode 'wdired-mode)
                            default-directory))))
      (find-file (+tramp-sudo-file-path this-file))
    (user-error "Current buffer not bound to a file")))

(defun +sudo-save-buffer ()
  "Save this buffer as root. Save as new file name if called with prefix."
  (interactive)
  (if-let ((file (or (and (or (not buffer-file-name) current-prefix-arg)
                          (read-file-name "Save as root to: "))
                     buffer-file-name))
           (file (+tramp-sudo-file-path (expand-file-name file)))
           (dest-buffer (find-file-noselect file))
           (src-buffer (current-buffer)))
      (progn
        (copy-to-buffer dest-buffer (point-min) (point-max))
        (unwind-protect (with-current-buffer dest-buffer (save-buffer))
          (unless (eq src-buffer dest-buffer) (kill-buffer dest-buffer))
          (with-current-buffer src-buffer (revert-buffer t t))))
    (user-error "Unable to open %S" (abbreviate-file-name file))))

(defun +yank-this-file-name ()
  "Yank the file name of this buffer."
  (interactive)
  (if-let ((file (buffer-file-name)))
      (with-temp-buffer
        (insert file)
        (kill-ring-save (point-min) (point-max)))
    (user-error "This buffer isn't bound to a file")))

(defun +clean-file-name (filename &optional downcase-p)
  "Clean FILENAME, optionally convert to DOWNCASE-P."
  ;; Clean slashes, backslashes, ":", ";", spaces, and tabs
  (replace-regexp-in-string
   "[:;\t\n\r /\\_]+" "-"
   (replace-regexp-in-string
    "[‘’‚“”„\"`'()&]+" ""
    (if downcase-p (downcase filename) filename))))
#+end_src

*** Hack from Minemacs
#+begin_src emacs-lisp
;;; Missing primitive utilities

;; See: emacs.stackexchange.com/q/3022/37002
(defun +reset-sym (sym)
  "Reset SYM to its standard value."
  (set sym (eval (car (get sym 'standard-value)))))

(defmacro +reset-var! (var)
  "Reset VAR to its standard value."
  `(setq ,var (eval (car (get ',var 'standard-value)))))

;; Adapted from `evil-unquote', takes functions into account
(defun +unquote (expr)
  "Return EXPR unquoted."
  (declare (pure t) (side-effect-free t))
  (while (memq (car-safe expr) '(quote function))
    (setq expr (cadr expr)))
  expr)

(defun +quoted-p (expr)
  "Return t when EXPR is quoted."
  (memq (car-safe expr) '(quote function)))

(defun +apply-partially-right (fun &rest args)
  "Like `apply-partially', but apply the ARGS to the right of FUN."
  (lambda (&rest args2)
    (apply fun (append args2 args))))

;;; Minemacs' core functions and macros
(defvar minemacs-msg-level 3)
(defmacro +log! (msg &rest vars)
 "Log MSG and VARS using `message' when `minemacs-verbose-p' is non-nil."
 (when (>= minemacs-msg-level 3)
   `(let ((inhibit-message t))
     (apply #'message (list (concat "[MinEmacs:Log] " ,msg) ,@vars)))))

(defmacro +cmdfy! (&rest body)
  "Convert BODY to an interactive command."
  `(lambda () (interactive) ,@body))

(defvar +eval-when-idle--task-num 0)
(defvar +eval-when-idle-delay 5.0)

(defun +eval-when-idle (delay &rest fns)
  "Queue FNS to be processed when Emacs becomes idle after DELAY seconds."
  (let* ((task-num (cl-incf +eval-when-idle--task-num))
        (task-name (make-symbol (format "+eval-when-idle--task-%d" task-num))))
    (with-memoization (get task-name 'timer)
      (run-with-idle-timer
      delay t
      (lambda ()
        (when-let (fn (pop fns))
          (+log! "Running task %d, calling function `%s'" task-num (truncate-string-to-width (format "%s" fn) 40 nil nil "…"))
          (funcall fn))
        (unless fns
          (cancel-timer (get task-name 'timer))
          (put task-name 'timer nil)))))))

(defmacro +eval-when-idle! (&rest body)
  "Evaluate BODY when Emacs becomes idle."
  (declare (indent 0))
  `(+eval-when-idle ,+eval-when-idle-delay (lambda () ,@body)))

(defmacro +eval-when-idle-for! (delay &rest body)
  "Evaluate BODY after DELAY seconds from Emacs becoming idle."
  (declare (indent 1))
  `(+eval-when-idle ,delay (lambda () ,@body)))

(defmacro +deferred! (&rest body)
  "Run BODY after Emacs gets loaded, a.k.a. after `minemacs-loaded'."
  `(with-eval-after-load 'minemacs-loaded ,@body))

(defmacro +deferred-when! (condition &rest body)
  "Like `+deferred!', with BODY executed only if CONDITION is non-nil."
  (declare (indent 1))
  `(when ,condition (+deferred! ,@body)))

(defmacro +make-first-file-hook! (filetype ext-regexp)
  "Make a hook which run on the first FILETYPE file of a particular extensions.
The extension should matches EXT-REGEXP.

This will creates a function named `+first-file--FILETYPE-h' which gets executed
before `after-find-file'. This function will run on the first file that matches
EXT-REGEXP. When it runs, this function provides a feature named
`minemacs-first-FILETYPE-file' and a run all hooks in
`minemacs-first-FILETYPE-file-hook'."
  (let* ((filetype (+unquote filetype))
         (fn-name (intern (format "+first-file-%s-h" (if filetype (format "-%s" filetype) ""))))
         (hook-name (intern (format "minemacs-first%s-file-hook" (if filetype (format "-%s" filetype) ""))))
         (feature-name (intern (format "minemacs-first%s-file" (if filetype (format "-%s" filetype) ""))))
         (hook-docs (format "This hook will be run after opening the first %s file (files that matches \"%s\").
Executed before `after-find-file', it runs all hooks in `%s' and provide the `%s' feature."
                            filetype ext-regexp hook-name feature-name)))
    `(progn
       (+log! "Setting up hook `%s' -- function `%s' -- feature `%s'."
        ',hook-name ',fn-name ',feature-name)
       (defvar ,hook-name nil ,hook-docs)
       (defun ,fn-name (&rest _)
        (when (and
               after-init-time ; after Emacs initialization
               (featurep 'minemacs-loaded) ; after MinEmacs is loaded
               (buffer-file-name) ; for named files
               (string-match-p ,ext-regexp (buffer-file-name))) ; file name matches the regexp
         (+log! "Running %d `%s' hooks." (length ,hook-name) ',hook-name)
         (advice-remove 'after-find-file #',fn-name)
         (provide ',feature-name)
         (run-hooks ',hook-name)))
       (if (daemonp)
           ;; Load immediately after init when in daemon mode
           (add-hook 'after-init-hook (lambda () (provide ',feature-name) (run-hooks ',hook-name)) #',fn-name 90)
         (advice-add 'after-find-file :before #',fn-name '((depth . -101)))))))

;; ========= Make some special hooks =========
(+make-first-file-hook! 'org "\\.org$")
(+make-first-file-hook! 'elisp "\\.elc?$")
(+make-first-file-hook! nil ".")

;; From Doom Emacs
(defun +resolve-hook-forms (hooks)
  "Convert a list of modes into a list of hook symbols.

If a mode is quoted, it is left as is. If the entire HOOKS list is quoted, the
list is returned as-is."
  (declare (pure t) (side-effect-free t))
  (let ((hook-list (ensure-list (+unquote hooks))))
    (if (eq (car-safe hooks) 'quote)
        hook-list
      (cl-loop for hook in hook-list
               if (eq (car-safe hook) 'quote)
               collect (cadr hook)
               else collect (intern (format "%s-hook" (symbol-name hook)))))))

(defun +setq-hook-fns (hooks rest &optional singles)
  (unless (or singles (= 0 (% (length rest) 2)))
    (signal 'wrong-number-of-arguments (list #'evenp (length rest))))
  (cl-loop with vars = (let ((args rest)
                             vars)
                         (while args
                           (push (if singles
                                     (list (pop args))
                                   (cons (pop args) (pop args)))
                                 vars))
                         (nreverse vars))
           for hook in (+resolve-hook-forms hooks)
           append
           (cl-loop for (var . val) in vars
                    collect
                    (list var val hook
                          (intern (format "+setq--%s-in-%s-h"
                                          var hook))))))

(defmacro +add-hook! (hooks &rest rest)
  "A convenience macro for adding N functions to M hooks.

This macro accepts, in order:

  1. The mode(s) or hook(s) to add to. This is either an unquoted mode, an
     unquoted list of modes, a quoted hook variable or a quoted list of hook
     variables.
  2. Optional properties :local, :append, and/or :depth [N], which will make the
     hook buffer-local or append to the list of hooks (respectively),
  3. The function(s) to be added: this can be a quoted function, a quoted list
     thereof, a list of `defun' or `cl-defun' forms, or arbitrary forms (will
     implicitly be wrapped in a lambda).

If the hook function should receive an argument (like in
`enable-theme-functions'), the `args' variable can be expanded in the forms

  (+add-hook! \\='enable-theme-functions
    (message \"Enabled theme: %s\" (car args)))

\(fn HOOKS [:append :local [:depth N]] FUNCTIONS-OR-FORMS...)"
  (declare (indent (lambda (indent-point state)
                     (goto-char indent-point)
                     (when (looking-at-p "\\s-*(")
                       (lisp-indent-defform state indent-point))))
           (debug t))
  (let* ((hook-forms (+resolve-hook-forms hooks))
         (func-forms ())
         (defn-forms ())
         append-p local-p remove-p depth)
    (while (keywordp (car rest))
      (pcase (pop rest)
        (:append (setq append-p t))
        (:depth  (setq depth (pop rest)))
        (:local  (setq local-p t))
        (:remove (setq remove-p t))))
    (while rest
      (let* ((next (pop rest))
             (first (car-safe next)))
        (push (cond ((memq first '(function nil))
                     next)
                    ((eq first 'quote)
                     (let ((quoted (cadr next)))
                       (if (atom quoted)
                           next
                         (when (cdr quoted)
                           (setq rest (cons (list first (cdr quoted)) rest)))
                         (list first (car quoted)))))
                    ((memq first '(defun cl-defun))
                     (push next defn-forms)
                     (list 'function (cadr next)))
                    ((prog1 `(lambda (&rest args) ,@(cons next rest))
                       (setq rest nil))))
              func-forms)))
    `(progn
       ,@defn-forms
       (dolist (hook (nreverse ',hook-forms))
        (dolist (func (list ,@func-forms))
         ,(if remove-p
              `(remove-hook hook func ,local-p)
            `(add-hook hook func ,(or depth append-p) ,local-p)))))))
;; From Doom Emacs
(defmacro +remove-hook! (hooks &rest rest)
  "A convenience macro for removing N functions from M hooks.

Takes the same arguments as `add-hook!'.

If N = 1 and M = 1, there's no benefit to using this macro over `remove-hook'.

\(fn HOOKS [:append :local] FUNCTIONS)"
  (declare (indent defun) (debug t))
  `(+add-hook! ,hooks :remove ,@rest))

;; From Doom Emacs
(defmacro +setq-hook! (hooks &rest var-vals)
  "Set buffer-local variables on HOOKS.

HOOKS can be expect receiving arguments (like in `enable-theme-functions'), the
`args' variable can be used inside VAR-VALS forms to get the arguments passed
the the function.

  (+setq-hook! \\='enable-theme-functions
    current-theme (car args))

\(fn HOOKS &rest [SYM VAL]...)"
  (declare (indent 1))
  (macroexp-progn
  (cl-loop for (var val hook fn) in (+setq-hook-fns hooks var-vals)
            collect `(defun ,fn (&rest args)
                      ,(format "%s = %s" var (pp-to-string val))
                      (setq-local ,var ,val))
            collect `(add-hook ',hook #',fn -90))))

;; From Doom Emacs
(defmacro +unsetq-hook! (hooks &rest vars)
  "Unbind setq hooks on HOOKS for VARS.

\(fn HOOKS &rest VAR1 VAR2...)"
  (declare (indent 1))
  (macroexp-progn
  (cl-loop for (_var _val hook fn)
            in (+setq-hook-fns hooks vars 'singles)
            collect `(remove-hook ',hook #',fn))))

;; Adapted from: Doom Emacs
(defun +compile-functions (&rest fns)
  "Queue FNS to be byte/natively-compiled after a brief delay."
  (dolist (fn fns)
    (+eval-when-idle!
      (or (and (featurep 'native-compile)
              (or (subr-native-elisp-p (indirect-function fn))
                  ;; Do not log to `comp-log-buffer-name'
                  (cl-letf (((symbol-function 'comp-log-to-buffer) #'ignore))
                    (+shutup! (ignore-errors (native-compile fn))))))
          (byte-code-function-p fn)
          (let (byte-compile-warnings)
            (+shutup! (byte-compile fn)))))))
#+end_src
*** Hack from Doom-emacs
#+begin_src emacs-lisp
(defmacro after! (package &rest body)
  "Evaluate BODY after PACKAGE have loaded.

PACKAGE is a symbol (or list of them) referring to Emacs features (aka
packages). PACKAGE may use :or/:any and :and/:all operators. The precise format
is:

- An unquoted package symbol (the name of a package)
    (after! helm BODY...)
- An unquoted, nested list of compound package lists, using any combination of
  :or/:any and :and/:all
    (after! (:or package-a package-b ...)  BODY...)
    (after! (:and package-a package-b ...) BODY...)
    (after! (:and package-a (:or package-b package-c) ...) BODY...)
- An unquoted list of package symbols (i.e. BODY is evaluated once both magit
  and git-gutter have loaded)
    (after! (magit git-gutter) BODY...)
  If :or/:any/:and/:all are omitted, :and/:all are implied.

This emulates `eval-after-load' with a few key differences:

1. No-ops for package that are disabled by the user (via `package!') or not
   installed yet.
2. Supports compound package statements (see :or/:any and :and/:all above).

Since the contents of these blocks will never by byte-compiled, avoid putting
things you want byte-compiled in them! Like function/macro definitions."
  (declare (indent defun) (debug t))
  (if (symbolp package)
      (unless (memq package (bound-and-true-p doom-disabled-packages))
        (list (if (or (not (bound-and-true-p byte-compile-current-file))
                      (require package nil 'noerror))
                  #'progn
                #'with-no-warnings)
              `(with-eval-after-load ',package ,@body)))
    (let ((p (car package)))
      (cond ((memq p '(:or :any))
             (macroexp-progn
              (cl-loop for next in (cdr package)
                       collect `(after! ,next ,@body))))
            ((memq p '(:and :all))
             (dolist (next (reverse (cdr package)) (car body))
               (setq body `((after! ,next ,@body)))))
            (`(after! (:and ,@package) ,@body))))))
#+end_src

*** Eglot
#+begin_src emacs-lisp
(defun +eglot-register (modes &rest servers)
  "Register MODES with LSP SERVERS.
Examples:
  (+eglot-register 'vhdl-mode \"vhdl_ls\")
  (+eglot-register 'lua-mode \"lua-language-server\" \"lua-lsp\")
  (+eglot-register '(c-mode c++-mode) '(\"clangd\" \"--clang-tidy\" \"-j=12\") \"ccls\")"
  (declare (indent 0))
  (with-eval-after-load 'eglot
    (add-to-list
     'eglot-server-programs
     (cons modes (if (length> servers 1)
                     (eglot-alternatives (ensure-list servers))
                   (ensure-list (car servers)))))))
#+end_src

** Package Manager
**** Elpaca
Elpaca is an elisp package manager. It allows users to find, install, update, and remove third-party packages for Emacs. It is a replacement for the built-in Emacs package manager, package.el
Github: https://github.com/progfolio/elpaca
***** Installer
#+begin_src emacs-lisp
(defvar elpaca-installer-version 0.6)
(defvar elpaca-directory (expand-file-name "elpaca/" my/local-dir))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil
                              :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
      (build (expand-file-name "elpaca/" elpaca-builds-directory))
      (order (cdr elpaca-order))
      (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (< emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                ((zerop (call-process "git" nil buffer t "clone"
                                      (plist-get order :repo) repo)))
                ((zerop (call-process "git" nil buffer t "checkout"
                                      (or (plist-get order :ref) "--"))))
                (emacs (concat invocation-directory invocation-name))
                ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                      "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                ((require 'elpaca))
                ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (load "./elpaca-autoloads")))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
#+end_src
***** use-package
Configure elpace `use-package` integration so that the rest of the configuration just uses `use-package`.
#+begin_src emacs-lisp
(elpaca elpaca-use-package
  ;; Enable :elpaca use-package keyword.
  (elpaca-use-package-mode)
  ;; Assume :elpaca t unless otherwise specified.
  (setq elpaca-use-package-by-default t))

;; Block until current queue processed.
(elpaca-wait)
#+end_src

***** use-feature
There are cases where we want to use `use-package` with internal packages.
In these cases `:elpaca nil` needs to be set. Let's create a macro `use-feature`
that combines `use-package` with `:elpaca nil` nicely.

Source: https://github.com/progfolio/.emacs.d/blob/master/init.org
#+begin_src emacs-lisp
(defmacro use-feature (name &rest args)
  "Like `use-package' but accounting for asynchronous installation.
  NAME and ARGS are in `use-package'."
  (declare (indent defun))
  `(use-package ,name
     :elpaca nil
     ,@args))
#+end_src

**** COMMENT MELPA
Sometimes I want to use package-xxx commands and query MELPA.
Since I don't do that often I expect this to be commented out most of the time.

#+begin_src emacs-lisp
(require 'package)
(add-to-list 'package-archives
  '("MELPA" .
    "http://melpa.org/packages/"))
(package-initialize)
#+end_src
** Fonts
The configured font needs to support the unicode characters that are used by the modeline.
The default font is good enough so let's not define additonal configuration here.
#+begin_src emacs-lisp
(push '(font . "IBM Plex Mono-18") default-frame-alist)
(set-face-font 'default "IBM Plex Mono-18")
(set-face-font 'variable-pitch "DejaVu Sans")
(copy-face 'default 'fixed-pitch)
#+end_src

** Theme
I prefer to keep my themes in a sub-folder of =~/.emacs.d=
#+begin_src emacs-lisp
(setq custom-theme-directory (concat my/emacs-dir "themes/"))
#+end_src

I'm working on a theme that is readable and attractive.

#+begin_src emacs-lisp
(defvar +theme 'mine "Default theme.")
(require 'cl-lib)
(require 'custom)
;; remove synthetic use-package theme
(unless (remq 'use-package custom-enabled-themes) (load-theme +theme t))
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package doom-themes
  :config
  (when (display-graphic-p)
    (load-theme 'doom-one t)(setq mode-line-format nil)))
#+end_src

** Startup hook
#+begin_src emacs-lisp
(defvar minemacs-after-startup-hook nil "This hook will be run after loading Emacs.")
(defun +minemacs--loaded-h ()
  ;; Require the virtual package to triggre loading packages depending on it
  (when minemacs-after-startup-hook
    (setq minemacs-after-startup-hook (reverse minemacs-after-startup-hook))
    (run-hooks 'minemacs-after-startup-hook))
    (provide 'minemacs-loaded))

;; Add it to the very beginning of `emacs-startup-hook'
(add-hook 'emacs-startup-hook #'+minemacs--loaded-h -101)
#+end_src

** Core
*** Settings
**** Native compilation settings
#+begin_src emacs-lisp
(when (featurep 'native-compile)
  (setq
  ;; Silence compiler warnings as they can be pretty disruptive, unless we are
  ;; running in `minemacs-verbose-p' mode.
  native-comp-async-report-warnings-errors 'silent
  native-comp-verbose 0 ; do not be too verbose
  native-comp-debug 0
  ;; Make native compilation happens asynchronously.
  native-comp-jit-compilation t)

  ;; Set the right directory to store the native compilation cache to avoid
  ;; messing with "~/.emacs.d/".
  (startup-redirect-eln-cache (concat my/cache-dir "eln/")))
#+end_src

**** emacs
#+begin_src emacs-lisp
(use-feature emacs
  :hook (after-save . +save--guess-file-mode-h)
  :custom
  ;; ====== Default directories for builtin packages ======
  (auto-save-list-file-prefix (+directory-ensure my/cache-dir "auto-save/"))
  (backup-directory-alist (list (cons "." (+directory-ensure my/cache-dir "backup/"))))
  (diary-file (concat my/cache-dir "diary"))
  (ecomplete-database-file (concat my/cache-dir "ecomplete-database.el"))
  (ede-project-placeholder-cache-file (concat my/cache-dir "ede-projects.el"))
  (erc-dcc-get-default-directory (+directory-ensure my/cache-dir "erc/dcc/"))
  (erc-log-channels-directory (+directory-ensure my/cache-dir "erc/log-channels/"))
  (eudc-options-file (concat my/cache-dir "eudc-options.el"))
  (eww-bookmarks-directory (+directory-ensure my/cache-dir "eww/bookmarks/"))
  (fortune-dir (+directory-ensure my/cache-dir "fortune/"))
  (fortune-file (expand-file-name "local" fortune-dir))
  (ido-save-directory-list-file (concat my/cache-dir "ido-save-directory-list.el"))
  (kkc-init-file-name (concat my/cache-dir "kkc-init.el"))
  (multisession-dir (concat my/cache-dir "multisession/"))
  (newsticker-cache-filename (concat my/cache-dir "newsticker/cache.el"))
  (newsticker-dir (+directory-ensure my/cache-dir "newsticker/data/"))
  (nsm-settings-file (concat my/cache-dir "nsm-settings.el"))
  (quickurl-url-file (concat my/cache-dir "quickurl-url.el"))
  (rcirc-log-directory (+directory-ensure my/cache-dir "rcirc/log/"))
  (remember-data-directory (+directory-ensure my/cache-dir "remember/data/"))
  (remember-data-file (concat my/cache-dir "remember/data.el"))
  (semanticdb-default-system-save-directory (concat my/cache-dir "semantic/"))
  (shadow-info-file (concat my/cache-dir "shadow/info.el"))
  (shadow-todo-file (concat my/cache-dir "shadow/todo.el"))
  (shared-game-score-directory (+directory-ensure my/cache-dir "shared-game-score/"))
  (srecode-map-save-file (concat my/cache-dir "srecode-map.el"))
  (timeclock-file (concat my/cache-dir "timeclock"))
  (type-break-file-name (concat my/cache-dir "type-break.el"))
  (viper-custom-file-name (concat my/cache-dir "viper.el"))

  ;; ====== Better defaults ======
  ;; Enable auto-save (use `recover-file' or `recover-session' to recover)
  (auto-save-default t)
  ;; Include big deletions
  (auto-save-include-big-deletions t)
  ;; Set file naming transform
  (auto-save-file-name-transforms
  `(;; Prefix tramp autosaves with "tramp-"
    ("\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\'" ,(concat auto-save-list-file-prefix "tramp-\\2") t)
    ;; Local autosaves
    (".*" ,auto-save-list-file-prefix t)))
  ;; Do not adjust window-vscroll to view tall lines. Fixes some lag issues see:
  ;; emacs.stackexchange.com/a/28746
  (auto-window-vscroll nil)
  ;; Fast scrolling
  (fast-but-imprecise-scrolling t)
  ;; Keep the point in the same position while scrolling
  (scroll-preserve-screen-position t)
  ;; Do not move cursor to the center when scrolling
  (scroll-conservatively 101)
  ;; Scroll at a margin of one line
  (scroll-margin 1)
  ;; The number of lines to scroll
  (scroll-step 1)
  ;; Columns from the window edge point allowed before horizontal scroll
  (hscroll-margin 2)
  ;; The number of columns to scroll
  (hscroll-step 1)
  ;; Disable lockfiles
  (create-lockfiles nil)
  ;; Enable making backup files
  (make-backup-files t)
  ;; Number each backup file
  (version-control t)
  ;; Copy instead of renaming current file
  (backup-by-copying t)
  ;; Clean up after itself
  (delete-old-versions t)
  ;; Keep up to 5 old versions of each file
  (kept-old-versions 5)
  ;; Keep up to 5 new versions of each file
  (kept-new-versions 5)
  ;; Keep up to 5 versions when cleaning a directory
  (dired-kept-versions 5)
  ;; Hitting TAB behavior
  (tab-always-indent 'complete)
  ;; End files with newline
  (require-final-newline t)
  ;; 10MB (default is 160kB)
  (undo-limit 10000000)
  ;; 50MB (default is 240kB)
  (undo-strong-limit 50000000)
  ;; 150MB (default is 24MB)
  (undo-outer-limit 150000000)
  ;; Use small frames to display tooltips instead of the default OS tooltips
  (use-system-tooltips nil)
  ;; Resize window combinations proportionally
  (window-combination-resize t)
  ;; Stretch cursor to the glyph width
  (x-stretch-cursor t)
  ;; Do force frame size to be a multiple of char size
  (frame-resize-pixelwise t)
  ;; Don’t compact font caches during GC
  (inhibit-compacting-font-caches t)
  ;; Increase single chunk bytes to read from subprocess (default 4096)
  (read-process-output-max (if os/linux
                              (condition-case nil
                                  ;; Android may raise permission-denied error
                                  (with-temp-buffer
                                    (insert-file-contents "/proc/sys/fs/pipe-max-size")
                                    (string-to-number (buffer-string)))
                                ;; If an error occurred, fallback to the default value
                                (error read-process-output-max))
                            (* 1024 1024)))
  ;; Don't prompt for confirmation when we create a new file or buffer
  (confirm-nonexistent-file-or-buffer nil)
  ;; Enable recursive calls to minibuffer
  (enable-recursive-minibuffers t)
  ;; Ignore case when completing
  (completion-ignore-case t)
  (read-buffer-completion-ignore-case t)
  ;; Display the true file name for symlinks
  (find-file-visit-truename t)
  ;; Use single space between sentences
  (sentence-end-double-space nil)
  ;; Move stuff to trash
  (delete-by-moving-to-trash t)
  ;; Save files only in sub-directories of current project
  (save-some-buffers-default-predicate #'save-some-buffers-root)
  ;; Inhibit startup message
  (inhibit-startup-screen t)
  ;; Do not ring
  (ring-bell-function #'ignore)
  ;; Set to non-nil to flash!
  (visible-bell nil)
  ;; Increase the large file threshold to 50 MiB
  (large-file-warning-threshold (* 50 1024 1024))
  ;; Initial scratch message (will be overridden if "fortune" is installed)
  (initial-scratch-message ";; MinEmacs -- start here!")
  ;; Set initial buffer to fundamental-mode for faster load
  (initial-major-mode 'fundamental-mode)
  ;; Always prompt in minibuffer (no GUI)
  (use-dialog-box nil)
  ;; Use y or n instead of yes or no
  (use-short-answers t)
  ;; Confirm before quitting
  (confirm-kill-emacs #'y-or-n-p)
  ;; Show unprettified symbol under cursor (when in `prettify-symbols-mode')
  (prettify-symbols-unprettify-at-point t)
  ;; Use a dashed line for `display-fill-column-indicator-mode'
  (display-fill-column-indicator-character ?\u250a)
  ;; Make apropos commands search more extensively
  (apropos-do-all t)
  ;; Do not ask obvious questions, follow symlinks
  (vc-follow-symlinks t)
  ;; Kill the shell buffer after exit
  (shell-kill-buffer-on-exit t)
  ;; More intuitive buffer naming style
  (uniquify-buffer-name-style 'forward)
  ;; No ugly button for widgets
  (widget-image-enable nil)
  ;; Make tooltips last a bit longer (default 10s)
  (tooltip-hide-delay 20)
  ;; Animated images loop forever instead of playing the animation only once
  (image-animate-loop t)
  :init
  (setq-default truncate-lines nil ; Display long lines
                fill-column 80 ; Default fill column width
                tab-width 2) ; Small tab is enough!

  ;; Inhibit startup message in echo area the brutal way!
  ;; The `inhibit-startup-echo-area-message' variable is very restrictive, there is only one unique way of setting it right!
  ;; See: reddit.com/r/emacs/comments/6e9o4o/comment/di8q1t5
  (fset 'display-startup-echo-area-message #'ignore)

  ;;; Why use anything but UTF-8?
  (prefer-coding-system 'utf-8)
  (set-charset-priority 'unicode)
  (set-default-coding-systems 'utf-8)
  ;; I use mainly English and French. Hence the "Latin-1" which is suitable for major Western Europe languages.
  (set-language-environment "Latin-1")
  (set-locale-environment "en_US.UTF-8")
  ;; Use UTF-16-LE in Windows, see: rufflewind.com/2014-07-20/pasting-unicode-in-emacs-on-windows
  (set-selection-coding-system (if os/win 'utf-16-le 'utf-8))
  :config
  ;; Show trailing whitespace in `prog-mode' and `conf-mode'
  (+setq-hook! (prog-mode conf-mode) show-trailing-whitespace t)

  ;; Guess the major mode after saving a file in `fundamental-mode' (adapted from Doom Emacs).
  (defun +save--guess-file-mode-h ()
    "Guess major mode when saving a file in `fundamental-mode'.
Likely, something has changed since the buffer was opened. e.g. A shebang line
or file path may exist now."
    (when (eq major-mode 'fundamental-mode)
      (let ((buffer (or (buffer-base-buffer) (current-buffer))))
        (and (buffer-file-name buffer)
            (eq buffer (window-buffer (selected-window))) ;; Only visible buffers
            (set-auto-mode)))))
  ;; Advice `emacs-session-filename' to ensure creating "session.ID" files in a sub-directory
  (advice-add
  #'emacs-session-filename :filter-return
  (defun +emacs-session-filename--in-subdir-a (session-filename)
    "Put the SESSION-FILENAME in the \"x-win/\" sub-directory."
    (concat (+directory-ensure my/cache-dir "x-win/")
            (file-name-nondirectory session-filename)))))
#+end_src

**** simple
#+begin_src emacs-lisp
(use-feature simple
  :init
  ;; Never mix, use only spaces
  (setq-default indent-tabs-mode nil)
  ;; Show line number in mode-line
  :hook (minemacs-after-startup . line-number-mode)
  ;; Show column numbers (a.k.a. cursor position) in the mode-line
  :hook (minemacs-after-startup . column-number-mode)
  ;; Display buffer size on mode line
  :hook (minemacs-after-startup . size-indication-mode)
  ;; Wrap long lines
  :hook ((prog-mode conf-mode text-mode) . visual-line-mode)
  :custom
  ;; Filter duplicate entries in kill ring
  (kill-do-not-save-duplicates t)
  ;; Save existing clipboard text into the kill ring before replacing it.
  (save-interprogram-paste-before-kill t))
#+end_src

**** help
#+begin_src emacs-lisp
(use-feature help
  :custom
  ;; Select help window for faster quit!
  (help-window-select t))
#+end_src

**** minibuffer
#+begin_src emacs-lisp
(use-feature minibuffer
  :custom
  ;; Ignores case when completing files names
  (read-file-name-completion-ignore-case t)
  ;; More info on completions
  (completions-detailed t))
#+end_src

**** dired
#+begin_src emacs-lisp
(use-feature dired
  ;; Enable adding mail attachments from dired "C-c RET C-a" for
  ;; `gnus-dired-attach'
  :hook (dired-mode . turn-on-gnus-dired-mode)
  :custom
  (dired-dwim-target t)
  (dired-auto-revert-buffer t))
#+end_src

**** image-dired
#+begin_src emacs-lisp
(use-feature image-dired
  :custom
  (image-dired-dir (+directory-ensure my/cache-dir "image-dired/"))
  (image-dired-tags-db-file (concat my/cache-dir "image-dired/tags-db.el"))
  (image-dired-temp-rotate-image-file (concat my/cache-dir "image-dired/temp-rotate-image")))
#+end_src

**** project
#+begin_src emacs-lisp
(use-feature project
  :demand t
  :hook (kill-emacs . project-forget-zombie-projects)
  :custom
  (project-list-file (concat my/cache-dir "project-list.el"))
  (project-vc-extra-root-markers '(".projectile.el" ".project.el" ".project")))
#+end_src

**** tab-bar
#+begin_src emacs-lisp
(use-feature tab-bar
  ;; :hook (minemacs-after-startup . tab-bar-mode)
  :custom
  (tab-bar-format '(tab-bar-format-history tab-bar-format-tabs tab-bar-separator))
  (tab-bar-tab-name-format-function #'+tab-bar-tab-spaced-name-format)
  (tab-bar-close-button-show nil)
  (tab-bar-auto-width-max '(150 20))
  (tab-bar-tab-hints t)
  (tab-bar-show nil)
  :config
  (defun +tab-bar-tab-spaced-name-format (tab i)
    (let ((current-p (eq (car tab) 'current-tab)))
      (propertize
       (concat (if tab-bar-tab-hints (format " %c " (+ ?❶ (1- i))) "")
               (alist-get 'name tab)
               (or (and tab-bar-close-button-show
                        (not (eq tab-bar-close-button-show
                                 (if current-p 'non-selected 'selected)))
                        tab-bar-close-button)
                   ""))
       'face (funcall tab-bar-tab-face-function tab))))
  (with-eval-after-load 'nerd-icons
    (setq tab-bar-close-button
          (propertize (concat (nerd-icons-faicon "nf-fa-close" :height 0.5) " ")
                      'close-tab t :help "Click to close tab"))))
#+end_src

**** eshell
#+begin_src emacs-lisp
(use-feature eshell
  :custom
  (eshell-aliases-file (concat my/cache-dir "eshell/aliases"))
  (eshell-directory-name (+directory-ensure my/cache-dir "eshell/"))
  (eshell-history-file-name (concat my/cache-dir "eshell/history.el"))
  (eshell-last-dir-ring-file-name (concat my/cache-dir "eshell/last-dir-ring.el"))
  (eshell-login-script (concat my/cache-dir "eshell/login"))
  (eshell-rc-script (concat my/cache-dir "eshell/rc"))
  (eshell-scroll-to-bottom-on-input 'this))
#+end_src

**** reftex
#+begin_src emacs-lisp
(use-feature reftex ;; Inspired by Doom Emacs
  :hook (reftex-toc-mode . reftex-toc-rescan)
  :custom
  ;; Get RefTeX working with BibLaTeX. See: tex.stackexchange.com/a/31992/43165
  (reftex-cite-format
   '((?a . "\\autocite[]{%l}")
     (?b . "\\blockcquote[]{%l}{}")
     (?c . "\\cite[]{%l}")
     (?f . "\\footcite[]{%l}")
     (?n . "\\nocite{%l}")
     (?p . "\\parencite[]{%l}")
     (?s . "\\smartcite[]{%l}")
     (?t . "\\textcite[]{%l}"))
   ;; This is needed when `reftex-cite-format' is set. See:
   ;; superuser.com/a/1386206
   (reftex-plug-into-AUCTeX t)
   (reftex-toc-split-windows-fraction 0.3))
  :config
  (+map-local! :keymaps 'reftex-mode-map
    ";" 'reftex-toc)
  (+nvmap! :keymaps 'reftex-toc-mode-map
    "j"   #'next-line
    "k"   #'previous-line
    "q"   #'kill-buffer-and-window
    "ESC" #'kill-buffer-and-window)
  (with-eval-after-load 'evil
    (add-hook 'reftex-mode-hook #'evil-normalize-keymaps)))
#+end_src

**** bibtex
#+begin_src emacs-lisp
(use-feature bibtex
  :hook (bibtex-mode . display-line-numbers-mode)
  :custom
  (bibtex-dialect 'biblatex)
  (bibtex-align-at-equal-sign t)
  (bibtex-text-indentation 20)
  :config
  (+map-local! :keymaps 'bibtex-mode-map
    "l" #'bibtex-fill-entry
    "r" #'bibtex-reformat))
#+end_src

**** treesit
#+begin_src emacs-lisp
(use-feature treesit
  :custom
  (treesit-font-lock-level 4))

(use-feature dockerfile-ts-mode
  :mode "/Dockerfile\\'")

(use-feature cmake-ts-mode
  :mode "CMakeLists\\.txt\\'"
  :mode "\\.cmake\\'")
#+end_src

**** autoinsert
#+begin_src emacs-lisp
(use-feature autoinsert
  :custom
  (auto-insert-directory (+directory-ensure my/cache-dir "auto-insert/")))
#+end_src

**** hideif
#+begin_src emacs-lisp
(use-feature hideif
  :custom
  (hide-ifdef-shadow t)
  (hide-ifdef-initially t))
#+end_src

**** hl-line
#+begin_src emacs-lisp
(use-feature hl-line
  ;; Highlight the current line
  :hook ((prog-mode conf-mode text-mode) . hl-line-mode))
#+end_src

**** hideshow
#+begin_src emacs-lisp
(use-feature hideshow
  ;; Hide/show code blocks, a.k.a. code folding
  :hook ((prog-mode conf-mode) . hs-minor-mode))
#+end_src

**** xref
#+begin_src emacs-lisp
(use-feature xref
  :custom
  ;; Use completion in the minibuffer instead of definitions buffer
  (xref-show-definitions-function #'xref-show-definitions-completing-read))
#+end_src

**** eldoc
#+begin_src emacs-lisp
(use-feature eldoc
  :custom
  (eldoc-documentation-strategy #'eldoc-documentation-compose))
#+end_src

**** compile
#+begin_src emacs-lisp
#+end_src

**** -mode
***** vhdl-mode
#+begin_src emacs-lisp
(use-feature vhdl-mode
  :config
  ;; Setup vhdl_ls from rust_hdl (AUR: rust_hdl-git)
  (+eglot-register 'vhdl-mode "vhdl_ls"))
#+end_src

***** verilog-mode
#+begin_src emacs-lisp
(use-feature verilog-mode
  :config
  ;; Setup Verilog/SystemVerilog LSP servers
  (+eglot-register 'verilog-mode "svls" "verible-verilog-ls" "svlangserver"))
#+end_src

***** nxml-mode
#+begin_src emacs-lisp
(use-feature nxml-mode
  :mode "\\.xmpi\\'"
  :config
  (+eglot-register '(nxml-mode xml-mode) "lemminx"))
#+end_src

***** elisp-mode
#+begin_src emacs-lisp
(use-feature elisp-mode
  :hook (emacs-lisp-mode . (lambda () (setq-local tab-width 8))) ;; to view built-in packages correctly
  :after minemacs-first-elisp-file ; prevent elisp-mode from being loaded too early
  :init
  (+map-local! :keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map ielm-map lisp-mode-map racket-mode-map scheme-mode-map)
    "p" #'check-parens)
  :config
  (+map-local! :keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map)
    "d"   '(nil :wk "edebug")
    "df"  #'edebug-defun
    "dF"  #'edebug-all-forms
    "dd"  #'edebug-all-defs
    "dr"  #'edebug-remove-instrumentation
    "do"  #'edebug-on-entry
    "dO"  #'edebug-cancel-on-entry
    "db"  '(nil :wk "breakpoints")
    "dbb" #'edebug-set-breakpoint
    "dbr" #'edebug-unset-breakpoint
    "dbn" #'edebug-next-breakpoint
    "e"   '(nil :wk "eval")
    "eb"  #'eval-buffer
    "ed"  #'eval-defun
    "ee"  #'eval-last-sexp
    "er"  #'eval-region
    "eR"  #'elisp-eval-region-or-buffer
    "el"  #'load-library
    "g"   '(nil :wk "goto/find")
    "gf"  #'find-function-at-point
    "gR"  #'find-function
    "gv"  #'find-variable-at-point
    "gV"  #'find-variable
    "gL"  #'find-library
    "c"   '(nil :wk "compile")
    "cc"  #'elisp-byte-compile-buffer
    "cf"  #'elisp-byte-compile-file
    "cn"  #'emacs-lisp-native-compile-and-load
    "cb"  #'emacs-lisp-byte-compile-and-load)
  (+map-local! :keymaps '(edebug-mode-map)
    "e"   '(nil :wk "eval")
    "ee"  #'edebug-eval-last-sexp
    "eE"  #'edebug-eval-expression
    "et"  #'edebug-eval-top-level-form)

  (defvar +emacs-lisp--face nil)
  (defvar +calculate-lisp-indent-check-for-keyword nil)
  (autoload #'ad-get-orig-definition "advice")

  ;; Extracted from:
  ;; github.com/doomemacs/doomemacs/blob/master/modules/lang/emacs-lisp/autoload.el
  (defun +emacs-lisp--highlight-vars-and-faces (end)
    "Match defined variables and functions.
Functions are differentiated into \"special forms\", \"built-in functions\" and
\"library/userland functions\"."
    (catch 'matcher
      (while (re-search-forward "\\(?:\\sw\\|\\s_\\)+" end t)
        (let ((ppss (save-excursion (syntax-ppss))))
          (cond ((nth 3 ppss)  ; strings
                 (search-forward "\"" end t))
                ((nth 4 ppss)  ; comments
                 (forward-line +1))
                ((let ((symbol (intern-soft (match-string-no-properties 0))))
                   (and (cond ((null symbol) nil)
                              ((eq symbol t) nil)
                              ((keywordp symbol) nil)
                              ((special-variable-p symbol)
                               (setq +emacs-lisp--face 'font-lock-variable-name-face))
                              ((and (fboundp symbol)
                                    (eq (char-before (match-beginning 0)) ?\()
                                    (not (memq (char-before (1- (match-beginning 0)))
                                               (list ?\' ?\`))))
                               (let ((unaliased (indirect-function symbol)))
                                 (unless (or (macrop unaliased)
                                             (special-form-p unaliased))
                                   (let (unadvised)
                                     (while (not (eq (setq unadvised (ad-get-orig-definition unaliased))
                                                     (setq unaliased (indirect-function unadvised)))))
                                     unaliased)
                                   (setq +emacs-lisp--face
                                         (if (subrp unaliased)
                                             'font-lock-constant-face
                                           'font-lock-function-name-face))))))
                        (throw 'matcher t)))))))
      nil))

  ;; Taken from:
  ;; reddit.com/r/emacs/comments/d7x7x8/finally_fixing_indentation_of_quoted_lists
  (defun +emacs-lisp--calculate-lisp-indent-a (&optional parse-start)
    "Add better indentation for quoted and backquoted lists."
    ;; The `calculate-lisp-indent-last-sexp' is defined with `defvar' with it's
    ;; value omitted, marking it special and only defining it locally. So if you
    ;; don't have this, you'll get a void variable error.
    (defvar calculate-lisp-indent-last-sexp)
    (save-excursion
      (beginning-of-line)
      (let ((indent-point (point))
            ;; Setting this to a number inhibits calling hook
            (desired-indent nil)
            (retry t)
            state calculate-lisp-indent-last-sexp containing-sexp)
        (cond ((or (markerp parse-start) (integerp parse-start))
               (goto-char parse-start))
              ((null parse-start) (beginning-of-defun))
              (t (setq state parse-start)))
        (unless state
          ;; Find outermost containing sexp
          (while (< (point) indent-point)
            (setq state (parse-partial-sexp (point) indent-point 0))))
        ;; Find innermost containing sexp
        (while (and retry state (> (elt state 0) 0))
          (setq retry nil
                containing-sexp (elt state 1)
                calculate-lisp-indent-last-sexp (elt state 2))
          ;; Position following last unclosed open.
          (goto-char (1+ containing-sexp))
          ;; Is there a complete sexp since then?
          (if (and calculate-lisp-indent-last-sexp (> calculate-lisp-indent-last-sexp (point)))
              ;; Yes, but is there a containing sexp after that?
              (let ((peek (parse-partial-sexp calculate-lisp-indent-last-sexp indent-point 0)))
                (if (setq retry (car (cdr peek))) (setq state peek)))))
        (unless retry
          ;; Innermost containing sexp found
          (goto-char (1+ containing-sexp))
          (if (not calculate-lisp-indent-last-sexp)
              ;; `indent-point' immediately follows open paren. Don't call hook.
              (setq desired-indent (current-column))
            ;; Find the start of first element of containing sexp.
            (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
            (cond ((looking-at "\\s("))
                  ;; First element of containing sexp is a list. Indent under that
                  ;; list.
                  ((> (save-excursion (forward-line 1) (point)) calculate-lisp-indent-last-sexp)
                   ;; This is the first line to start within the containing sexp.
                   ;; It's almost certainly a function call.
                   (if (or
                        ;; Containing sexp has nothing before this line except the
                        ;; first element. Indent under that element.
                        (= (point) calculate-lisp-indent-last-sexp)

                        ;; First sexp after `containing-sexp' is a keyword. This
                        ;; condition is more debatable. It's so that I can have
                        ;; unquoted plists in macros. It assumes that you won't
                        ;; make a function whose name is a keyword.
                        (and +calculate-lisp-indent-check-for-keyword
                             (when-let (char-after (char-after (1+ containing-sexp)))
                               (char-equal char-after ?:)))

                        ;; Check for quotes or backquotes around.
                        (let* ((positions (elt state 9))
                               (last (car (last positions)))
                               (rest (reverse (butlast positions)))
                               (any-quoted-p nil)
                               (point nil))
                          (or
                           (when-let (char (char-before last))
                             (or (char-equal char ?')
                                 (char-equal char ?`)))
                           (progn
                             (while (and rest (not any-quoted-p))
                               (setq point (pop rest)
                                     any-quoted-p
                                     (or
                                      (when-let (char (char-before point))
                                        (or (char-equal char ?') (char-equal char ?`)))
                                      (save-excursion
                                        (goto-char (1+ point))
                                        (looking-at-p "\\(?:back\\)?quote[\t\n\f\s]+(")))))
                             any-quoted-p))))
                       ;; Containing sexp has nothing before this line except the
                       ;; first element. Indent under that element.
                       nil
                     ;; Skip the first element, find start of second (the first
                     ;; argument of the function call) and indent under.
                     (progn (forward-sexp 1)
                            (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)))
                   (backward-prefix-chars))
                  (t
                   ;; Indent beneath first sexp on same line as
                   ;; `calculate-lisp-indent-last-sexp'. Again, it's almost
                   ;; certainly a function call.
                   (goto-char calculate-lisp-indent-last-sexp)
                   (beginning-of-line)
                   (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
                   (backward-prefix-chars)))))
        ;; Point is at the point to indent under unless we are inside a string.
        ;; Call indentation hook except when overridden by `lisp-indent-offset' or
        ;; if the desired indentation has already been computed.
        (let ((normal-indent (current-column)))
          (cond ((elt state 3)
                 ;; Inside a string, don't change indentation.
                 nil)
                ((and (integerp lisp-indent-offset) containing-sexp)
                 ;; Indent by constant offset
                 (goto-char containing-sexp)
                 (+ (current-column) lisp-indent-offset))
                ;; in this case `calculate-lisp-indent-last-sexp' is not `nil'
                (calculate-lisp-indent-last-sexp
                 (or
                  ;; try to align the parameters of a known function
                  (and lisp-indent-function
                       (not retry)
                       (funcall lisp-indent-function indent-point state))
                  ;; If the function has no special alignment or it does not apply
                  ;; to this argument, try to align a constant-symbol under the
                  ;; last preceding constant symbol, if there is such one of the
                  ;; last 2 preceding symbols, in the previous uncommented line.
                  (and (save-excursion
                         (goto-char indent-point)
                         (skip-chars-forward " \t")
                         (looking-at ":"))
                       ;; The last sexp may not be at the indentation where it
                       ;; begins, so find that one, instead.
                       (save-excursion
                         (goto-char calculate-lisp-indent-last-sexp)
                         ;; Handle prefix characters and whitespace following an
                         ;; open paren. (Bug#1012)
                         (backward-prefix-chars)
                         (while (not (or (looking-back "^[ \t]*\\|([ \t]+" (line-beginning-position))
                                         (and containing-sexp (>= (1+ containing-sexp) (point)))))
                           (forward-sexp -1)
                           (backward-prefix-chars))
                         (setq calculate-lisp-indent-last-sexp (point)))
                       (> calculate-lisp-indent-last-sexp
                          (save-excursion
                            (goto-char (1+ containing-sexp))
                            (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
                            (point)))
                       (let ((parse-sexp-ignore-comments t)
                             indent)
                         (goto-char calculate-lisp-indent-last-sexp)
                         (or (and (looking-at ":")
                                  (setq indent (current-column)))
                             (and (< (line-beginning-position) (prog2 (backward-sexp) (point)))
                                  (looking-at ":")
                                  (setq indent (current-column))))
                         indent))
                  ;; another symbols or constants not preceded by a constant as
                  ;; defined above.
                  normal-indent))
                ;; in this case `calculate-lisp-indent-last-sexp' is `nil'
                (desired-indent)
                (t
                 normal-indent))))))

  ;; Override the `calculate-lisp-indent' to indent plists correctly. See:
  ;; reddit.com/r/emacs/comments/d7x7x8/finally_fixing_indentation_of_quoted_lists/
  (advice-add 'calculate-lisp-indent :override #'+emacs-lisp--calculate-lisp-indent-a)

  ;; Better fontification for Emacs Lisp code (colorizes functions, ...)
  (font-lock-add-keywords 'emacs-lisp-mode '((+emacs-lisp--highlight-vars-and-faces . +emacs-lisp--face)))

  ;; HACK: Adapted from Doom. Quite a few functions here are called often, and
  ;; so are especially performance sensitive, so we compile these functions
  ;; on-demand.
  (+compile-functions #'+emacs-lisp--highlight-vars-and-faces #'+emacs-lisp--calculate-lisp-indent-a))
#+end_src

**** electric
#+begin_src emacs-lisp
(use-feature electric
  :config
  ;; Electric indent on delete and enter
  (setq-default electric-indent-chars '(?\n ?\^?))

  (defvar-local +electric-indent-words '()
    "The list of electric words. Typing these will trigger reindentation of the
current line.")

  ;; Electric indent at Bash/Sh keywords, extracted from the grammar
  (+setq-hook! (sh-mode bash-ts-mode)
    +electric-indent-words
    (delete-dups (apply #'append (mapcar (lambda (e) (list (car e) (cdr e))) (cdar sh-smie-sh-grammar)))))

  ;; From Doom Emacs
  (add-hook
   'electric-indent-functions
   (defun +electric-indent-char-fn (_c)
     (when (and (eolp) +electric-indent-words)
       (save-excursion
         (backward-word)
         (looking-at-p (concat "\\<" (regexp-opt +electric-indent-words))))))))
#+end_src

**** elec-pair
#+begin_src emacs-lisp
(use-feature elec-pair
  :hook (minemacs-after-startup . electric-pair-mode)
  :init
  (defun +electric-pair-tweaks-h ()
    ;; Org mode tweaks
    (with-eval-after-load 'elec-pair
      (when (bound-and-true-p electric-pair-mode)
        ;; Disable auto-pairing of "<" in `org-mode' when using `electric-pair-mode'
        (setq-local electric-pair-inhibit-predicate
                    `(lambda (char)
                       (if (char-equal char ?<) t (,electric-pair-inhibit-predicate char)))))
      (setq-local electric-pair-pairs (append electric-pair-pairs (alist-get major-mode +electric-pair-mode-pairs-alist)))))

  (defvar +electric-pair-mode-pairs-alist
    '((org-mode      . ((?= . ?=) (?~ . ?~) (?` . ?')))
      (markdown-mode . ((?` . ?`) (?* . ?*)))))

  ;; Add the hooks to the concerned modes
  (dolist (mode (mapcar #'car +electric-pair-mode-pairs-alist))
    (add-hook (intern (format "%s-hook" mode)) #'+electric-pair-tweaks-h)))
#+end_src

**** abbrev
#+begin_src emacs-lisp
(use-feature abbrev
  :custom
  (abbrev-file-name (concat my/cache-dir "abbrev.el")))
#+end_src

**** bookmark
#+begin_src emacs-lisp
(use-feature bookmark
  :custom
  (bookmark-default-file (concat my/cache-dir "bookmark.el"))
  ;; Save the bookmarks every time a bookmark is made
  (bookmark-save-flag 1))
#+end_src

**** calc
#+begin_src emacs-lisp
(use-feature calc
  :custom
  (calc-settings-file (concat my/cache-dir "calc-settings.el")))
#+end_src

**** desktop
#+begin_src emacs-lisp
(use-feature desktop
  :custom
  ;; File name to use when saving desktop
  (desktop-base-file-name "emacs-session.el")
  ;; File name to use as a lock
  (desktop-base-lock-name (concat desktop-base-file-name ".lock"))
  ;; Load only 5 buffers immediately, the remaining buffers will be loaded lazily
  (desktop-restore-eager 5)
  ;; Avoid writing contents unchanged between auto-saves
  (desktop-file-checksum t)
  ;; Save buffer status
  (desktop-save-buffer t))
#+end_src

**** recentf
#+begin_src emacs-lisp
(use-feature recentf
  :demand t
  :custom
  (recentf-save-file (concat my/cache-dir "recentf-save.el"))
  ;; Increase the maximum number of saved items
  (recentf-max-saved-items 100)
  ;; Ignore case when searching recentf files
  (recentf-case-fold-search t)
  ;; Exclude some files from being remembered by recentf
  (recentf-exclude
  `(,(rx (or "/elfeed-db/" "/eln-cache/" "/cache/" "/.maildir/" "/.cache/"))
    ,(rx bol "/" (or "tmp/" "rsync:" "ssh:" "sudoedit:" "sudo:"))))
  :config
  ;; Enable `recentf-mode' to remember recent files
  (recentf-mode 1))
#+end_src

**** url
#+begin_src emacs-lisp
(use-feature url
  :custom
  (url-cache-directory (+directory-ensure my/cache-dir "url/"))
  (url-configuration-directory (+directory-ensure my/cache-dir "url/"))
  (url-cookie-file (concat my/cache-dir "url/cookie.el"))
  (url-history-file (concat my/cache-dir "url/history.el")))
#+end_src

**** webjump
#+begin_src emacs-lisp
(use-feature webjump
  :custom
  (webjump-sites
  '(("Emacs Wiki"    . [simple-query "www.emacswiki.org" "www.emacswiki.org/cgi-bin/wiki/" ""])
    ("DuckDuckGo"    . [simple-query "duckduckgo.com" "duckduckgo.com/?q=" ""])
    ("Qwant"         . [simple-query "www.qwant.com" "www.qwant.com/?q=" ""])
    ("Ecosia"        . [simple-query "www.ecosia.org" "www.ecosia.org/search?q=" ""])
    ("Brave"         . [simple-query "search.brave.com" "search.brave.com/search?q=" ""])
    ("Bing"          . [simple-query "www.bing.com" "www.bing.com/search?q=" ""])
    ("Yahoo"         . [simple-query "www.yahoo.com" "search.yahoo.com/search?p=" ""])
    ("Google"        . [simple-query "www.google.com" "www.google.com/search?q=" ""])
    ("Google Maps"   . [simple-query "www.google.com" "www.google.com/maps?q=" ""])
    ("Google Images" . [simple-query "www.google.com" "www.google.com/images?q=" ""])
    ("Google Groups" . [simple-query "groups.google.com" "groups.google.com/groups?q=" ""])
    ("StackOverflow" . [simple-query "stackoverflow.com" "stackoverflow.com/search?q=" ""])
    ("GitHub Repo"   . [simple-query "github.com" "github.com/search?type=repositories&q=" ""])
    ("GitHub Code"   . [simple-query "github.com" "github.com/search?type=code&q=" ""])
    ("WolframAlpha"  . [simple-query "wolframalpha.com" "wolframalpha.com/input/?i=" ""])
    ("MDN"           . [simple-query "developer.mozilla.org" "developer.mozilla.org/search?q=" ""])
    ("Youtube"       . [simple-query "www.youtube.com" "www.youtube.com/results?search_query=" ""])
    ("Reddit"        . [simple-query "www.reddit.com" "www.reddit.com/search/?q=" ""])
    ("Wikipedia"     . [simple-query "wikipedia.org" "wikipedia.org/wiki/" ""]))))
#+end_src

**** time-stamp
#+begin_src emacs-lisp
(use-feature time-stamp
  ;; Update time stamp (if available) before saving a file.
  :hook (before-save . time-stamp)
  :custom
  ;; Do enable time-stamps
  (time-stamp-active t)
  ;; Check the first 12 buffer lines for Time-stamp: <>
  (time-stamp-line-limit 12)
  ;; Timestamp format
  (time-stamp-format "%04Y-%02m-%02d %02H:%02M:%02S"))
#+end_src

**** whitespace
#+begin_src emacs-lisp
(use-feature whitespace
  :custom
  ;; Default behavior for `whitespace-cleanup'
  (whitespace-action '(cleanup auto-cleanup)))
#+end_src

**** autorevert
#+begin_src emacs-lisp
(use-feature autorevert
  ;; Auto load files changed on disk
  :hook (minemacs-first-file . global-auto-revert-mode)
  :custom
  ;; Revert non-file buffers like dired
  (global-auto-revert-non-file-buffers t))
#+end_src

**** savehist
#+begin_src emacs-lisp
(use-feature savehist
  :hook (minemacs-after-startup . savehist-mode)
  :custom
  (savehist-file (concat my/cache-dir "savehist.el")))
#+end_src

**** saveplace
#+begin_src emacs-lisp
(use-feature saveplace
  ;; Save place in files
  :hook (minemacs-first-file . save-place-mode)
  :custom
  (save-place-file (concat my/cache-dir "save-place.el")))
#+end_src

**** term
#+begin_src emacs-lisp
(use-feature term
  :config
  ;; Kill `term' buffer on exit (reproduce a similar behavior to `shell's
  ;; `shell-kill-buffer-on-exit').
  (advice-add
   'term-sentinel :around
   (defun +term--kill-after-exit-a (orig-fn proc msg)
     (if (memq (process-status proc) '(signal exit))
         (let ((buffer (process-buffer proc)))
           (apply orig-fn (list proc msg))
           (kill-buffer buffer))
       (apply orig-fn (list proc msg))))))
#+end_src

**** excutable
#+begin_src emacs-lisp
(use-feature executable
  ;; Make scripts (files starting with shebang "#!") executable when saved
  :hook (after-save . executable-make-buffer-file-executable-if-script-p))
#+end_src

**** display-line-numbers
#+begin_src emacs-lisp
(use-feature display-line-numbers
  ;; Show line numbers
  :hook ((prog-mode conf-mode text-mode) . display-line-numbers-mode)
  :custom
  ;; Relative line numbering
  (display-line-numbers-type 'relative)
  ;; Width for line numbers
  (display-line-numbers-width 4)
  ;; Display absolute line numbers in narrowed regions
  (display-line-numbers-widen t)
  :config
  ;; I don't want display line number in org mode
  (add-hook 'org-mode-hook (lambda () (display-line-numbers-mode -1)))
)
#+end_src

**** pixel-scroll
#+begin_src emacs-lisp
(use-feature pixel-scroll
  :after minemacs-loaded
  :demand t
  :custom
  ;; Better scrolling on Emacs29+, specially on a touchpad
  (pixel-scroll-precision-use-momentum t)
  :config
  ;; Scroll pixel by pixel, in Emacs29+ there is a more pricise mode way to scroll
  (if (>= emacs-major-version 29)
      (pixel-scroll-precision-mode 1)
    (pixel-scroll-mode 1)))
#+end_src

**** mouse
#+begin_src emacs-lisp
(use-feature mouse
  ;; Enable context menu on mouse right click
  :defer t
  :hook (minemacs-after-startup . context-menu-mode)
  :custom
  ;; Enable Drag-and-Drop of regions
  (mouse-drag-and-drop-region t)
  ;; Enable Drag-and-Drop of regions from Emacs to external programs
  (mouse-drag-and-drop-region-cross-program t))

  (use-feature mwheel
  :custom
  ;; Make mouse scroll a little faster
  (mouse-wheel-scroll-amount '(2 ((shift) . hscroll) ((meta) . nil) ((control meta) . global-text-scale) ((control) . text-scale)))
  ;; Make mouse scroll a little faster horizontally
  (mouse-wheel-scroll-amount-horizontal 2))

(use-feature xt-mouse
  :hook (tty-setup . xterm-mouse-mode))
#+end_src

**** frame
#+begin_src emacs-lisp
(use-feature frame
  ;; Display divider between windows
  :hook (minemacs-after-startup . window-divider-mode)
  :custom
  ;; Set line width for the divider in `window-divider-mode' to 2px
  (window-divider-default-bottom-width 2)
  (window-divider-default-right-width 2))
#+end_src

**** winner
#+begin_src emacs-lisp
(use-feature winner
  ;; Window layout undo/redo (`winner-undo' / `winner-redo')
  :hook (minemacs-after-startup . winner-mode))
#+end_src

**** delsel
#+begin_src emacs-lisp
(use-feature delsel
  ;; Replace selection after start typing
  :hook (minemacs-after-startup . delete-selection-mode))
#+end_src

**** so-long
#+begin_src emacs-lisp
(use-feature so-long
  ;; Better handling for files with so long lines
  :hook (minemacs-after-startup . global-so-long-mode))
#+end_src

**** windmove
#+begin_src emacs-lisp
(use-feature windmove
  :demand t
  :config
  ;; Navigate windows using Shift+Direction
  (windmove-default-keybindings 'shift))
#+end_src

**** pulse
#+begin_src emacs-lisp
(use-feature pulse
  :init
  ;; Add visual pulse when changing focus, like beacon but built-in
  ;; From: https://karthinks.com/software/batteries-included-with-emacs/
  (defun +pulse-line (&rest _)
    "Pulse the current line."
    (pulse-momentary-highlight-one-line (point)))
  (dolist (command '(scroll-up-command scroll-down-command recenter-top-bottom other-window))
    (advice-add command :after #'+pulse-line)))
#+end_src

* Packages
** Evil (Like vim)
#+begin_quote
Evil is an extensible vi layer for Emacs. It emulates the main features of Vim, and provides facilities for writing custom extensions.

https://github.com/emacs-evil/evil
#+end_quote

#+begin_src emacs-lisp
(use-package evil
  :hook (minemacs-after-startup . evil-mode)
  :preface
  ;; Needed by `evil-collection'
  (setq evil-want-keybinding nil
        evil-want-integration t)
  :custom
  (evil-want-C-i-jump nil)
  (evil-want-fine-undo t)
  (evil-want-Y-yank-to-eol t)
  (evil-split-window-below t)
  (evil-vsplit-window-right t)
  (evil-kill-on-visual-paste nil)
  (evil-undo-system 'undo-redo)
  ;; BUG: setting this to t triggers errors on pressing . to repeat command
  (evil-respect-visual-line-mode nil)
  (evil-ex-interactive-search-highlight 'selected-window)
  :config
  (+map!
    ;; buffer
    "bN" '(evil-buffer-new :wk "New buffer")
    ;; window
    "ww" '(evil-window-next :wk "Next")
    "wW" '(evil-window-prev :wk "Previous")
    "ws" '(evil-window-split :wk "Split")
    "wv" '(evil-window-vsplit :wk "Vertical split")
    "wr" '(evil-window-rotate-downwards :wk "Rotate downwards")
    "wR" '(evil-window-rotate-upwards :wk "Rotate upwards")
    "w+" '(evil-window-increase-width :wk "Increase width")
    "w-" '(evil-window-decrease-width :wk "Decrease width"))

  ;; Use `isearch', it integrates better with other commands like
  ;; `consult-isearch-history'
  (evil-select-search-module 'evil-search-module 'isearch)
  ;; I want use Ctrl-f to consult-line
  (define-key evil-motion-state-map "\C-f" nil))
  #+end_src

*** evil-collection
#+begin_quote
This is a collection of Evil bindings for the parts of Emacs that Evil does not cover properly by default.

https://github.com/emacs-evil/evil-collection
#+end_quote
#+begin_src emacs-lisp
(use-package evil-collection
  :after evil minemacs-loaded
  :demand t
  :config
  (evil-collection-init
   (seq-filter
    (lambda (mode)
      (not (memq mode '(evil-mc ; Default bindings for `evil-mc' are messy
                        elisp-mode)))) ; I don't like "gz" for `ielm', I like "gr" though
    evil-collection-mode-list))

  ;; Use "gr" to find references for elisp mode
  (with-eval-after-load 'elisp-mode
    (when evil-collection-want-find-usages-bindings
      (evil-collection-define-key 'normal 'emacs-lisp-mode-map
        "gr" 'xref-find-references))))
#+end_src

*** evil-snipe
#+begin_src emacs-lisp
(use-package evil-snipe
  :after evil
  :hook (minemacs-after-startup . evil-snipe-mode)
  :hook (minemacs-after-startup . evil-snipe-override-mode)
  :custom
  (evil-snipe-scope 'buffer)
  (evil-snipe-smart-case t)
  (evil-snipe-auto-scroll t))
#+end_src

*** evil-nerd-commenter
#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :commands evilnc-comment-operator
  :init
  (+nvmap!
    "gc" #'evilnc-comment-operator
    "gC" #'evilnc-copy-and-comment-operator))
#+end_src

** Key-Bindding
*** Which-key
#+begin_quote
which-key is a minor mode for Emacs that displays the key bindings following your currently entered incomplete command (a prefix) in a popup.

https://github.com/justbur/emacs-which-key
#+end_quote

#+begin_src emacs-lisp
(use-package which-key
  :hook (minemacs-after-startup . which-key-mode)
  :custom
  (which-key-idle-delay 0.5)
  (which-key-idle-secondary-delay nil)
  (which-key-ellipsis "..")
  (which-key-prefix-prefix "+")
  (which-key-sort-order #'which-key-key-order-alpha)
  (which-key-min-display-lines 3)
  (which-key-max-display-columns nil)
  ;; Allow a key binding to be modified by multiple rules in
  ;; `which-key-replacement-alist'
  (which-key-allow-multiple-replacements t)
  :config
  (setq
   which-key-replacement-alist
   (append
    which-key-replacement-alist
    (list
     '(("\\`g z" . "\\`evil-\\(?:mc\\|multiedit\\)-\\(.*\\)")    . (nil . "⌶·\\1"))
     '(("\\`g c" . "\\`evilnc-\\(.*\\)")                         . (nil . "#·\\1"))
     '(("\\`g" . "\\`[Ii]nfo[-:]?\\(?:a-\\)?\\(.*\\)")           . (nil . "ɩ·\\1"))
     '(("\\`SPC TAB" . "\\`tabspaces-\\(.*\\)")                  . (nil . "⭾·\\1"))
     '(("\\`SPC p" . "\\`\\+?\\(?:consult-\\)?project-\\(.*\\)") . (nil . "π·\\1"))
     '(("" . "\\`evil[-:]?\\(?:a-\\)?\\(.*\\)")                  . (nil . "ɛ·\\1")))))
  ;; Setup `which-key' integration with the minibuffer
  (which-key-setup-minibuffer))
#+end_src

*** General (key-bindings)
#+begin_quote
general.el provides a more convenient method for binding keys in emacs (for both evil and non-evil users).

https://github.com/noctuid/general.el#about
#+end_quote

Load general before the remaining packages so they can make use of the ~:general~ keyword in their declarations.
#+begin_src emacs-lisp :noweb yes
  (use-package general
    :after (evil)
    :demand t
    :config
    (general-override-mode)
    (general-auto-unbind-keys)
    (general-evil-setup t) ;; needed for nmap, ...
    <<general-config>>
    (provide 'me-general-ready))
  (elpaca-wait)
#+end_src

**** config
:properties:
:header-args: :tangle no :noweb-ref general-config
:end:
The global definer allows me to use a leader key in most states.
#+begin_src emacs-lisp
(general-create-definer +leader-key!
 :keymaps 'override
 :states '(insert normal hybrid motion visual operator emacs)
 :prefix "SPC"
 :global-prefix "S-SPC")
#+end_src

We define a global-leader definer to access major-mode specific bindings:
#+begin_src emacs-lisp
(general-create-definer +localleader-key!
  :keymaps 'override
  :states '(insert normal hybrid motion visual operator)
  :prefix "SPC m"
  :non-normal-prefix "S-SPC m"
  "" '( :ignore t
        :which-key
        (lambda (arg)
          (cons (cadr (split-string (car arg) " "))
                (replace-regexp-in-string "-mode$" "" (symbol-name major-mode))))))
#+end_src

;; To handle repeated "SPC u" like repeated "C-u"
#+begin_src emacs-lisp
(general-def
  :keymaps 'universal-argument-map
  :prefix "SPC"
  :global-prefix "S-SPC"
  "u" #'universal-argument-more)
#+end_src


***** Bind
#+begin_src emacs-lisp
(+leader-key!
  ;; ====== Top level functions ======
  "SPC"  '(execute-extended-command :wk "M-x")
  ">"    '(switch-to-next-buffer :wk "Next buffer")
  "<"    '(switch-to-prev-buffer :wk "Previous buffer")
  ";"    '(pp-eval-expression :wk "Eval expression")
  ":"    #'project-find-file
  "X"    #'org-capture
  "u"    '(universal-argument :wk "C-u")
  "C"    #'universal-coding-system-argument
  "O"    #'other-window-prefix
  "!"   'shell-command
  "z"   '((lambda (local) (interactive "p")
            (unless repeat-mode (repeat-mode))
            (let ((local current-prefix-arg)
                  (current-prefix-arg nil))
              (call-interactively (if local #'text-scale-adjust #'global-text-scale-adjust))))
          :which-key "zoom")

  ;; ====== Quit/Session ======
  "q"    '(nil :wk "quit/session")
  "qq"   #'save-buffers-kill-terminal
  "qQ"   #'kill-emacs
  "qS"   #'server-start
  "qR"   #'recover-session
  "qd"   #'desktop-read
  "qD"   #'desktop-lazy-complete
  "qs"   #'desktop-save

  ;; ====== Files ======
  "f"    '(nil :wk "file")
  "fS"   '(write-file :wk "Save as ...")
  "fd"   #'+delete-this-file
  "fD"   #'+delete-this-file-and-buffer
  "fF"   #'+sudo-find-file ; will be overriten with `sudo-edit-find-file'
  "fu"   #'+sudo-this-file ; will be overriten with `sudo-edit'
  "fi"   #'auto-insert
  "fR"   #'+move-this-file
  "ff"   #'find-file
  "fs"   #'save-buffer
  "ft"   #'recover-this-file
  "fT"   #'recover-file
  "fy"   #'+yank-this-file-name
  "fE"   `(,(+cmdfy! (dired (or my/emacs-dir minemacs-root-dir)))
           :wk "User config directory")

  ;; ====== Buffers ======
  "b"    '(nil :wk "buffer")
  "bI"   #'ibuffer
  "bu"   #'+sudo-save-buffer
  "bx"   #'bury-buffer
  "bS"   #'save-some-buffers
  "bs"   #'+scratch-open-project-scratch-buffer
  "bM"   #'view-echo-area-messages
  "bA"   #'+kill-some-buffers
  "bk"   `(,(+cmdfy! (kill-buffer (current-buffer)))
          :wk "Kill this buffer")
  "bK"   `(,(+cmdfy! (+kill-buffer-and-its-windows (current-buffer)))
          :wk "Kill this buffer and its windows")
  "br"   '(revert-buffer :wk "Revert")
  "bR"   '(rename-buffer :wk "Rename")
  ;; Lines
  "bl"   '(nil :wk "line")

  ;; ====== Window ======
  "w"    '(nil :wk "window")
  "wd"   #'delete-window
  "wD"   #'delete-windows-on
  "wo"   #'delete-other-windows
  "wm"   #'maximize-window
  "wu"   #'winner-undo
  "wU"   #'winner-redo

  ;; ====== Applications (Open) ======
  "o"    '(nil :wk "open")
  "o-"   '(dired :wk "Dired") ;; Will be overwritten if dirvish is used
  "oa"   #'org-agenda

  ;; ====== Search ======
  "s"    '(nil :wk "search")

  ;; ====== VC ======
  "g"    '(nil :wk "git/vc")

  ;; ====== Workspaces ======
  "TAB"  '(nil :wk "workspace")

  ;; ====== Code ======
  "c"    '(nil :wk "code")
  "cf"   '(nil :wk "format buffer")
  "ce"   '(nil :wk "eglot session")
  "cee"  #'eglot

  ;; ====== Debug ======
  "d"    '(nil :wk "debug")
  "dG"   #'gdb

  ;; ====== Notes ======
  "n"    '(nil :wk "notes")

   ;; ====== Help ======
  "h"    '(nil :wk "help")
  "hi"   #'info
  "hg"   #'general-describe-keybindings
  "he"   '(nil :wk "elisp/emacs")
  "hes"  #'elisp-index-search
  "hem"  #'info-emacs-manual
  "hei"  #'Info-search
  "hd"   '(nil :wk "describe")
  "hdk"  #'describe-key
  "hdm"  #'describe-keymap
  "hdb"  #'describe-bindings
  "hds"  #'describe-symbol
  "hdv"  #'describe-variable
  "hdc"  #'describe-command
  "hdf"  #'describe-function
  "hdp"  #'describe-package


  ;; ====== Extras ======
  "e"    '(nil :wk "extras")

  ;; ====== Project ======
  "p"    '(nil :wk "project")
  "pw"  #'project-switch-project
  "pc"  #'project-compile
  "pd"  #'project-find-dir
  "pf"  #'project-find-file
  "pk"  #'project-kill-buffers
  "pb"  #'project-switch-to-buffer
  ;; "pa"  #'+project-add-project
  ;; "pD"  #'+dir-locals-open-or-create
  "p-"  #'project-dired
  "px"  #'project-execute-extended-command
  ;; compile/test
  "pc" #'project-compile
  ;; run
  "pr"  '(nil :wk "run")
  "pre" #'project-eshell
  ;; "prg" #'+project-gdb
  "prs" #'project-shell
  "prc" #'project-shell-command
  "prC" #'project-async-shell-command
  ;; forget
  "pF"  '(nil :wk "forget/cleanup")
  "pFz" #'project-forget-zombie-projects
  "pFp" #'project-forget-project
  "pFu" #'project-forget-projects-under
  ;; "pFc" #'+project-list-cleanup
  ;; search/replace
  "ps"  '(nil :wk "search/replace")
  "pss" #'project-search
  "psn" '(fileloop-continue :wk "Next match")
  "psr" #'project-query-replace-regexp
  "psf" #'project-find-regexp
)
#+end_src

Exit minibuffer from anywhere
#+begin_src emacs-lisp
;; Kill the minibuffer even when in another windown.
;; Adapted from: trey-jackson.blogspot.com/2010/04/emacs-tip-36-abort-minibuffer-when.html
(defun +minibuffer-kill-minibuffer ()
  "Kill the minibuffer from anywhere."
  (interactive)
  (when (and (>= (recursion-depth) 1) (active-minibuffer-window))
    (abort-recursive-edit)))

(keymap-global-set "S-<escape>" #'+minibuffer-kill-minibuffer)
#+end_src

*** Avy
#+begin_src emacs-lisp
(use-package avy
  :bind (("C-;" . avy-goto-char-timer)
         ("C-é" . avy-goto-line) ; French AZERTY
         ("M-g l" . avy-goto-line)))
#+end_src
** UI
*** Nerd Icon
#+begin_src emacs-lisp
(defun +font-installed-p (font-family)
  "Check if FONT-FAMILY is installed on the system."
  (and font-family (member font-family (font-family-list)) t))
(use-package nerd-icons
  :config
  ;; Show .m files as matlab/octave files (integral icon)
  (setcdr (assoc "m" nerd-icons-extension-icon-alist)
          '(nerd-icons-mdicon "nf-md-math_integral_box" :face nerd-icons-orange))
  (when (and (display-graphic-p) (not (+font-installed-p nerd-icons-font-family)))
    (nerd-icons-install-fonts 'dont-ask)))
#+end_src

*** Dashboard
#+begin_src emacs-lisp
(use-package dashboard
  :after evil evil-collection
  :demand t
  :init
  (+map! "oD" #'dashboard-open)
  :custom
  (dashboard-set-heading-icons t)
  (dashboard-set-file-icons t)
  (dashboard-center-content t)
  (dashboard-banner-ascii "MinEmacs")
  (dashboard-banner-logo-title "Welcome to MinEmacs!")
  (dashboard-items '((recents . 5) (projects . 5) (bookmarks . 5)))
  (dashboard-image-banner-max-width 600)
  (dashboard-projects-backend 'project-el)
  ;; (dashboard-startup-banner (concat minemacs-assets-dir "images/minemacs.png"))
  :config
  ;; Ensure setting the keybindings before opening the dashboard
  (evil-collection-dashboard-setup)

  ;; Avoid opening the dashboard when Emacs starts with an open file.
  (unless (cl-some #'buffer-file-name (buffer-list))
    (dashboard-open)))
#+end_src

*** Rainbow
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
(use-package rainbow-mode
  :hook (prog-mode . rainbow-mode))
#+end_src

*** Doom-modeline
#+begin_quote
A fancy and fast mode-line inspired by minimalism design.

https://github.com/seagle0128/doom-modeline
#+end_quote

#+begin_src emacs-lisp
(use-package doom-modeline
  :hook (minemacs-after-startup . doom-modeline-mode)
  :custom
  (doom-modeline-height 28)
  (doom-modeline-bar-width 8)
  (doom-modeline-time-icon nil)
  (doom-modeline-buffer-encoding 'nondefault)
  (doom-modeline-unicode-fallback t)
  (doom-modeline-enable-word-count t)
  (doom-modeline-continuous-word-count-modes
   '(markdown-mode gfm-mode org-mode rst-mode latex-mode tex-mode text-mode))
  :config
  ;; HACK: Add some padding to the right
  (doom-modeline-def-modeline 'main
    '(eldoc bar workspace-name window-number modals matches follow buffer-info
      remote-host buffer-position word-count parrot selection-info)
    '(compilation objed-state misc-info persp-name battery grip irc mu4e gnus
      github debug repl lsp minor-modes input-method indent-info buffer-encoding
      major-mode process vcs checker time "  ")))
#+end_src

*** Solaire
#+begin_src emacs-lisp
(use-package solaire-mode
  :hook (minemacs-after-startup . solaire-global-mode)
  :config
  (dolist (face '(mode-line mode-line-active mode-line-inactive mode-line-emphasis))
    (setf (alist-get face solaire-mode-remap-alist) nil)))
#+end_src

*** Treesit-auto
#+begin_src emacs-lisp
(use-package treesit-auto
  :custom
  (treesit-auto-install 'prompt)
  :config
  (treesit-auto-add-to-auto-mode-alist 'all)
  (global-treesit-auto-mode))
#+end_src

** Tools
*** Expand Region
#+begin_src emacs-lisp
(use-package expand-region
  :bind ("C-q" . er/expand-region))
#+end_src

*** Undo
#+begin_src emacs-lisp
;; Visual Undo
(use-package vundo
  :init
  (+map! "ou" #'vundo)
  :custom
  (vundo-compact-display t)
  (vundo-window-max-height 8)
  (vundo-glyph-alist vundo-unicode-symbols))

(use-package undo-fu-session
  :init (undo-fu-session-global-mode)
  :demand t
  :custom
  (undo-fu-session-compression (if (executable-find "zstd") 'zst 'gz))
  (undo-fu-session-directory (concat my/cache-dir "undo-fu-session/")))
#+end_src

*** Term
#+begin_src emacs-lisp
(use-package vterm
  :bind (:map vterm-mode-map ("<return>" . vterm-send-return))
  :commands (vterm vterm-other-window)
  :init
  (+map!
    "t" '(:ignore t :which-key "terminal")
    "tt" 'vterm-other-window
    "t." 'vterm)
  :custom
    (vterm-max-scrollback 5000)
    (vterm-tramp-shells '(("docker" "/bin/bash")))
  :config
    (evil-set-initial-state 'vterm-mode 'emacs))
#+end_src

*** Format
#+begin_src emacs-lisp
(use-package apheleia
  :init
  (+map! "cff" #'apheleia-format-buffer))
;; :config
;; Hack from Doom-Emacs
(cl-defun set-formatter! (name args &key modes)
  (declare (indent defun))
  (cl-check-type name symbol)
  (after! apheleia
    (if (null args)
      (progn
        (setq apheleia-formatters
                (assq-delete-all name apheleia-formatters))
        (while (rassoc name apheleia-mode-alist)
            (setq apheleia-mode-alist
                (assq-delete-all (car (rassoc name apheleia-mode-alist)) apheleia-mode-alist))))
      (let ((formatter (cond
                        ((listp args) `(,@args))
                        (t args))))
        (setf (alist-get name apheleia-formatters) formatter))
      (when modes
        (dolist (mode modes)
          (setf (alist-get mode apheleia-mode-alist) name))))))
#+end_src

** Completion
*** Cape
#+begin_src emacs-lisp
(use-package cape
  :after minemacs-loaded
  :demand t
  :init
  (defcustom +cape-global-capes
    '(tempel-complete :completion cape-dict)
    "A list of global capes to be available at all times.
The key `:completion' is used to specify where completion candidates should be
placed, otherwise they come first."
    :group 'minemacs-completion
    :type '(repeat symbol))
  (defcustom +cape-hosts
    '(eglot-completion-at-point
      lsp-completion-at-point
      elisp-completion-at-point
      tags-completion-at-point-function)
    "A prioritised list of host capfs to create a super cape onto from
`+cape-global-capes'."
    :group 'minemacs-completion
    :type '(repeat function))
  :config
  ;; Silence the pcomplete capf, no errors or messages! Important for corfu!
  (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)

  (when (< emacs-major-version 29)
    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify))
  ;; Add to the global default value of `completion-at-point-functions' which is
  ;; used by `completion-at-point'.  The order of the functions matters, the
  ;; first function returning a result wins.  Note that the list of buffer-local
  ;; completion functions takes precedence over the global list.
  (+add-hook! 'completion-at-point-functions '(cape-file cape-elisp-block cape-keyword cape-dict))

  (+add-hook! (emacs-lisp-mode git-commit-mode)
    (add-hook 'completion-at-point-functions #'cape-symbol nil t))

  (+add-hook! (TeX-mode LaTeX-mode)
    (add-hook 'completion-at-point-functions #'cape-tex nil t))

  ;; Make use of `cape''s super Capf functionality. Adapted from:
  ;; git.sr.ht/~gagbo/doom-config/tree/master/item/modules/completion/corfu/config.el
  (defun +cape-apply-capf-super ()
    "Apply Capf super to all capes specified in `+cape-global-capes' and `+cape-hosts'."
    (interactive)
    (when-let ((host (cl-intersection +cape-hosts completion-at-point-functions)))
      (setq-local
       completion-at-point-functions
       (cl-substitute (apply #'cape-capf-super
                             (cl-substitute (car host)
                                            :completion
                                            (append (cl-pushnew :completion +cape-global-capes))))
                      (car host)
                      completion-at-point-functions))))

  (defun +toggle-cape-auto-capf-super (&optional disable)
    "Enable auto generating Cape's super Capf.
This depends on `+cape-hosts' and `+cape-global-capes'."
    (interactive)
    (let ((enabled (get '+cape-auto-capf-super 'enabled)))
      (dolist (hook '(lsp-mode-hook eglot-managed-mode-hook change-major-mode-hook))
        (apply (if (or enabled disable) #'remove-hook #'add-hook) (list hook #'+cape-apply-capf-super))
        (put '+cape-auto-capf-super 'enabled (not (or enabled disable)))))))
#+end_src

*** Corfu
#+begin_src emacs-lisp
(use-package corfu
  :elpaca (corfu :host github :repo "minad/corfu" :files (:defaults "extensions/*.el"))
  :hook (minemacs-after-startup . global-corfu-mode)
  :hook (eshell-mode . +corfu-less-intrusive-h)
  :hook (minibuffer-setup . +corfu-enable-in-minibuffer-h)
  :bind (:map corfu-map
         ("M-m" . +corfu-complete-in-minibuffer)
         ("<tab>" . corfu-next)
         ("<backtab>" . corfu-previous)
         ("C-j" . corfu-next)
         ("C-k" . corfu-previous))
  :custom
  (corfu-auto t) ; Enable auto completion
  (corfu-cycle t) ; Allows cycling through candidates
  (corfu-min-width 25)
  (corfu-auto-delay 0.2)
  :config
  (defun +corfu-enable-in-minibuffer-h ()
    "Enable Corfu in the minibuffer if `completion-at-point' is bound."
    (when (where-is-internal #'completion-at-point (list (current-local-map)))
      (setq-local corfu-auto nil) ; Enable/disable auto completion
      (corfu-mode 1)))

  (defun +corfu-less-intrusive-h ()
    (setq-local corfu-quit-at-boundary t
                corfu-quit-no-match t
                corfu-auto nil)
    (corfu-mode 1))

  ;; Taken from:
  ;; git.sr.ht/~gagbo/doom-config/tree/master/item/modules/completion/corfu/config.el
  (defun +corfu-complete-in-minibuffer ()
    "Move current completions to the minibuffer."
    (interactive)
    (let ((completion-extra-properties corfu--extra)
          completion-cycle-threshold
          completion-cycling)
      (apply #'consult-completion-in-region completion-in-region--data))))
#+end_src

**** corfu-popupinfo
#+begin_src emacs-lisp
(use-feature corfu-popupinfo
  :hook (corfu-mode . corfu-popupinfo-mode)
  :bind (:package corfu
         :map corfu-map
         ("M-p" . corfu-popupinfo-scroll-down)
         ("M-n" . corfu-popupinfo-scroll-up)
         ("M-d" . corfu-popupinfo-toggle))
  :custom
  (corfu-popupinfo-delay 0.1)
  (corfu-popupinfo-max-height 15))
#+end_src

**** corfu-history
#+begin_src emacs-lisp
(use-feature corfu-history
  :hook (corfu-mode . corfu-history-mode)
  :config
  (unless (bound-and-true-p savehist-mode)
    (savehist-mode 1))
  (add-to-list 'savehist-additional-variables 'corfu-history))
#+end_src

**** corfu-terminal
#+begin_src emacs-lisp
(use-package corfu-terminal
  :hook (corfu-mode . corfu-terminal-mode))
#+end_src

**** nerd-icons-corfu
#+begin_src emacs-lisp
(use-package nerd-icons-corfu
  :after corfu
  :demand t
  :config
  (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src

*** Consult
#+begin_src emacs-lisp
(defun +region-or-thing-at-point ()
  "Return the region or the thing at point."
  (when-let ((thing (ignore-errors
                      (or (prog1 (thing-at-point 'region t)
                            (deactivate-mark))
                          (cl-some (+apply-partially-right #'thing-at-point t)
                                   '(symbol email number string word))))))
    ;; If the matching thing has multi-lines, join them
    (string-join (string-lines thing))))
#+end_src

#+begin_src emacs-lisp
(use-package consult
  :hook (embark-collect-mode . consult-preview-at-point-mode)
  :bind (("C-f" . consult-line)
         :map minibuffer-local-map
         ("C-r" . consult-history)
         ("C-S-v" . consult-yank-pop)
         :package isearch
         :map isearch-mode-map
         ("C-S-v" . consult-yank-pop))
  :custom
  ;; Use `consult-xref' for `xref-find-references'
  (xref-show-xrefs-function #'consult-xref)
  ;; Better formatting for `view-register'
  (register-preview-function #'consult-register-format)
  :init
  (+map!
    ;; buffer
    "bll" #'consult-line
    "blf" #'consult-focus-lines
    "blk" #'consult-keep-lines
    "blg" #'consult-goto-line
    "bb"  #'consult-buffer
    "bB"  #'consult-buffer-other-window
    "bF"  #'consult-buffer-other-frame
    "bmM" #'consult-bookmark
    "bi"  #'consult-imenu
    "bO"  #'consult-outline
    ;; file
    "fr"  #'consult-recent-file
    ;; git/vc
    "gG"  #'consult-git-grep
    ;; search
    "ss"  (if (executable-find "rg") #'consult-ripgrep #'consult-grep)
    "sf"  (if (executable-find "fd") #'consult-fd #'consult-find)
    "sM"  #'consult-man
    "st"  #'consult-locate
    "sh"  #'consult-history
    "sa"  #'consult-org-agenda
    "sl"  #'consult-locate
    "si"  #'consult-isearch-history
    ;; project
    "pl"  #'consult-line-multi
    "pi"  #'consult-imenu-multi
    ;; code
    "cm"  #'consult-flymake
    "cE"  #'consult-compile-error
    ;; extras
    "ec"  #'consult-complex-command
    ;; insert
    "iy"  #'consult-yank-from-kill-ring
    "ip"  #'consult-yank-pop
    "ir"  '(nil :wk "register")
    "irr" #'consult-register
    "irl" #'consult-register-load
    "irs" #'consult-register-store
    ;; help
    "hu"  #'consult-theme
    "hI"  #'consult-info)
  (+map-local! :keymaps 'org-mode-map
    "h"   #'consult-org-heading)
  :config
  (setq-default completion-in-region-function #'consult-completion-in-region)

  ;; Fill the initial query of `consult' commands from region or thing at point.
  ;; (consult-customize
  ;;  consult-find :initial (+region-or-thing-at-point)
  ;;  consult-grep :initial (+region-or-thing-at-point)
  ;;  consult-line :initial (+region-or-thing-at-point)
  ;;  consult-line-multi :initial (+region-or-thing-at-point)
  ;;  consult-man :initial (+region-or-thing-at-point)
  ;;  consult-ripgrep :initial (+region-or-thing-at-point))
)
#+end_src

**** consult-dir
#+begin_src emacs-lisp
(use-package consult-dir
  :bind (("C-x C-d" . consult-dir)
         :package vertico
         :map vertico-map
         ("C-x C-d" . consult-dir)
         ("C-x C-j" . consult-dir-jump-file))
  :init
  (+map! "ed" #'consult-dir))
#+end_src

*** Embark
#+begin_src emacs-lisp
(use-package embark
  :bind (("<remap> <describe-bindings>" . embark-bindings)
         ("C-²" . embark-act) ; In a French AZERTY keyboard, the ² key is right above TAB
         ("M-²" . embark-collect)
         ("C-&" . embark-dwim))
  :init
  ;; Use Embark to show bindings in a key prefix with `C-h`
  (setq prefix-help-command #'embark-prefix-help-command)
  (+map!
    "a" #'embark-act
    "A" #'embark-collect))
#+end_src

**** embark-consult
#+begin_src emacs-lisp
(use-package embark-consult
  :after embark consult
  :hook (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

*** Marginalia
#+begin_src emacs-lisp
(use-package marginalia
  :hook (minemacs-after-startup . marginalia-mode))
#+end_src

**** nerd-icons-completion
#+begin_src emacs-lisp
(use-package nerd-icons-completion
  :hook (marginalia-mode . nerd-icons-completion-marginalia-setup))
#+end_src

*** Orderless
#+begin_src emacs-lisp
(use-package orderless
  :after minemacs-loaded
  :demand t
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

*** Vertico
#+begin_src emacs-lisp
(use-package vertico
  :elpaca (vertico :host github :repo "minad/vertico" :files (:defaults "extensions/*"))
  :hook (minemacs-after-startup . vertico-mode)
  ;; In the minibuffer, "C-k" is be mapped to act like "<up>". However, in
  ;; Emacs, "C-k" have a special meaning of `kill-line'. So lets map "C-S-k"
  ;; to serve the original "C-k".
  :bind (:map vertico-map
         ("C-j" . vertico-next)
         ("C-k" . vertico-previous)
         :map minibuffer-local-map
         ("C-S-k" . kill-line))
  :custom
  (vertico-cycle t)
  (vertico-resize nil)
  (vertico-count 12))
#+end_src

**** vertico-directory
#+begin_src emacs-lisp
(use-feature vertico-directory
  :after vertico
  :demand t
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy)
  :bind (:map vertico-map
         ("RET" . vertico-directory-enter)
         ("DEL" . vertico-directory-delete-char)
         ("M-DEL" . vertico-directory-delete-word)
         ("M-h" . vertico-directory-up)))
#+end_src

**** vertico-repeat
#+begin_src emacs-lisp
(use-feature vertico-repeat
  :hook (minibuffer-setup . vertico-repeat-save)
  :bind ("M-R" . vertico-repeat))
#+end_src

** Eglot
#+begin_src emacs-lisp
(use-package eglot
  :hook (eglot-managed-mode . eglot-inlay-hints-mode)
  :custom
  (eglot-autoshutdown t) ; shutdown after closing the last managed buffer
  (eglot-sync-connect 0) ; async, do not block
  (eglot-extend-to-xref t) ; can be interesting!
  (eglot-report-progress nil) ; disable annoying messages in echo area!
  :config
  (+map! :keymaps 'eglot-mode-map
    :infix "c"
    "fF" #'eglot-format-buffer
    "d"  '(eglot-find-declaration :wk "Find declaration")
    "i"  '(eglot-find-implementation :wk "Find implementation")
    "t"  '(eglot-find-typeDefinition :wk "Find type definition")
    "a"  '(eglot-code-actions :wk "Code actions")
    "r"  '(nil :wk "refactor")
    "rr" '(eglot-rename :wk "Rename")
    "rR" '(eglot-code-action-rewrite :wk "Rewrite")
    "rf" '(eglot-code-action-quickfix :wk "Quick fix")
    "ri" '(eglot-code-action-inline :wk "Inline")
    "re" '(eglot-code-action-extract :wk "Extract")
    "ro" '(eglot-code-action-organize-imports :wk "Organize imports")
    "eq" '(eglot-shutdown :wk "Shutdown")
    "er" '(eglot-reconnect :wk "Reconnect")
    "eQ" '(eglot-shutdown-all :wk "Shutdown all")
    "w"  '(eglot-show-workspace-configuration :wk "Eglot workspace config"))

  (+eglot-register
    '(c++-mode c++-ts-mode c-mode c-ts-mode)
    '("clangd"
      "--background-index"
      "-j=12"
      "--query-driver=/usr/bin/**/clang-*,/bin/clang,/bin/clang++,/usr/bin/gcc,/usr/bin/g++"
      "--clang-tidy"
      ;; "--clang-tidy-checks=*"
      "--all-scopes-completion"
      "--cross-file-rename"
      "--completion-style=detailed"
      "--header-insertion-decorators"
      "--header-insertion=iwyu"
      "--pch-storage=memory")
    "ccls")

  (+eglot-register '(awk-mode awk-ts-mode) "awk-language-server"))
#+end_src

** Lang
*** Nix
#+begin_src emacs-lisp
;; (use-package nix-mode)
(use-package nix-mode
  :mode "\\.nix\\'")
  ;; :config
  ;; ;; Register Eglot servers on the `nix-ts-mode' in addition to the already configured `nix-mode'
  ;; (with-eval-after-load 'eglot
  ;;   (when-let ((server (assoc 'nix-mode eglot-server-programs)))
  ;;     (setcar server '(nix-mode nix-ts-mode)))))
  :config
  (set-formatter! 'alejandra '("alejandra" "-q" "-") :modes '(nix-mode))
#+end_src

*** Markdown
#+begin_src emacs-lisp
(use-package markdown-mode
  :mode ("README\\.md\\'" . gfm-mode)
  :custom
  (markdown-hide-markup t)
  (markdown-enable-html t)
  (markdown-enable-math t)
  :config
  (+map-local! :keymaps 'markdown-mode-map
    "l"  '(nil :wk "link")
    "ll" #'markdown-insert-link
    "e"  #'markdown-export))
#+end_src
*** Org-mode
**** org
#+begin_src emacs-lisp
(use-feature org
  :preface
  ;; Set to nil so we can detect user changes (in config.el)
  (setq org-directory "~/Desktop/org/"
        ;; Fix `evil' search problem (to be used with `evil-search')
        org-fold-core-style 'overlays)
  :custom
  (org-auto-align-tags nil)
  (org-clock-persist-file (concat my/cache-dir "org/clock-persist.el"))
  (org-cycle-hide-block-startup t)
  (org-edit-src-auto-save-idle-delay auto-save-timeout) ; use the defaults
  (org-edit-src-content-indentation 0) ; do not indent the content of src blocks
  (org-edit-src-turn-on-auto-save t) ; auto-save org-edit-src
  (org-ellipsis " ↩")
  (org-export-async-init-file (expand-file-name (concat my/cache-dir "extras/me-org-export-async-init.el")))
  (org-export-in-background t) ; run export processes in external emacs process
  (org-export-with-broken-links 'mark) ; Do not rise error on broken links, but mark them in the output file
  (org-export-with-smart-quotes t) ; convert "this" to « this »
  (org-export-with-sub-superscripts '{}) ; Only explicit _{} ^{} are interpreted as sub/superscripts
  (org-fold-catch-invisible-edits 'smart) ; try not to accidentally do weird stuff in invisible regions
  (org-fontify-quote-and-verse-blocks t)
  (org-hide-emphasis-markers t)
  (org-highlight-latex-and-related '(native script entities))
  (org-id-locations-file (concat my/cache-dir "org/id-locations.el"))
  (org-insert-heading-respect-content t)
  (org-list-allow-alphabetical t) ; have a. A. a) A) list bullets
  (org-log-done 'time) ; having the time an item is done sounds convenient
  (org-persist-directory (+directory-ensure my/cache-dir "org/persist/"))
  (org-pretty-entities t)
  (org-pretty-entities-include-sub-superscripts t)
  (org-preview-latex-image-directory (+directory-ensure my/cache-dir "org/preview/latex-image/"))
  (org-publish-timestamp-directory (+directory-ensure my/cache-dir "org/publish/timestamps/"))
  (org-return-follows-link t) ; RET follows link (a key bind has to be defined for Evil, see below)
  (org-special-ctrl-a/e t)
  (org-startup-indented nil)
  (org-tags-column 0)
  (org-use-property-inheritance t) ; it's convenient to have properties inherited
  (org-use-sub-superscripts '{}) ; Do the same when rendering the Org buffer
  :config
  (+map-local! :keymaps 'org-mode-map
    "l"  '(nil :wk "link")
    "ll" #'org-insert-link
    "e"  #'org-export-dispatch
    "c"  #'org-edit-src-code
    "s"  '(nil :wk "babel-session")
    "sc" #'org-babel-switch-to-session-with-code
    "ss" #'org-babel-switch-to-session
    "sp" #'org-babel-pop-to-session
    "sP" #'org-babel-pop-to-session-maybe
    "sl" #'org-babel-load-in-session
    "sL" #'org-babel-load-in-session-maybe
    "si" #'org-babel-initiate-session
    "b"  '(nil :wk "babel")
    "bt" #'org-babel-tangle
    "bd" #'org-babel-detangle
    "bf" #'org-babel-tangle-file)
  (+map-local! :keymaps 'org-src-mode-map
    "s" #'org-edit-src-save
    "q" #'org-edit-src-abort
    "e" #'org-edit-src-exit)
  (+nmap! :keymaps 'org-mode-map
    "RET" #'org-open-at-point)

  (setq org-export-async-debug nil) ;; Can be useful!

  ;; Dynamically change font size for Org heading levels, starting from
  ;; `+org-level-base-size', and shrinking by a factor of 0.9 at each level.
  (defvar +org-level-base-size 1.3)

  (dotimes (level 8)
    (let ((size (max 1.0 (* +org-level-base-size (expt 0.9 level)))))
      (set-face-attribute
       (intern (format "org-level-%d" (1+ level))) nil
       :weight 'bold
       :height size)))

  (org-babel-do-load-languages
   'org-babel-load-languages
   (cl-loop
    for lang in '(C R js dot awk sed sql org shell ditaa latex julia sqlite octave
                  maxima eshell scheme python fortran gnuplot plantuml makefile)
    collect (cons lang t)))

  (with-eval-after-load 'org-src
    (setq org-src-lang-modes
          (append
           '(("dot" . graphviz-dot))
           (delete (assoc "dot" org-src-lang-modes #'equal) org-src-lang-modes))))

  (with-eval-after-load 'plantuml-mode
    (setq org-plantuml-jar-path plantuml-jar-path
          org-plantuml-exec-mode plantuml-default-exec-mode
          org-plantuml-executable-path plantuml-executable-path))

  ;; From Doom Emacs
  (with-no-warnings
    (custom-declare-face '+org-todo-active  '((t (:inherit (bold font-lock-constant-face org-todo)))) "")
    (custom-declare-face '+org-todo-project '((t (:inherit (bold font-lock-doc-face org-todo)))) "")
    (custom-declare-face '+org-todo-onhold  '((t (:inherit (bold warning org-todo)))) "")
    (custom-declare-face '+org-todo-cancel  '((t (:inherit (bold error org-todo)))) ""))

  (setq org-todo-keywords
        '((sequence
           "TODO(t)"  ; A task that needs doing & is ready to do
           "PROJ(p)"  ; A project, which usually contains other tasks
           "LOOP(r)"  ; A recurring task
           "STRT(s)"  ; A task that is in progress
           "WAIT(w)"  ; Something external is holding up this task
           "HOLD(h)"  ; This task is paused/on hold because of me
           "IDEA(i)"  ; An unconfirmed and unapproved task or notion
           "|"
           "DONE(d)"  ; Task successfully completed
           "KILL(k)") ; Task was cancelled, aborted or is no longer applicable
          (sequence
           "[ ](T)"   ; A task that needs doing
           "[-](S)"   ; Task is in progress
           "[?](W)"   ; Task is being held up or paused
           "|"
           "[X](D)")  ; Task was completed
          (sequence
           "|"
           "OKAY(o)"
           "YES(y)"
           "NO(n)"))
        org-todo-keyword-faces
        '(("[-]"  . +org-todo-active)
          ("STRT" . +org-todo-active)
          ("[?]"  . +org-todo-onhold)
          ("WAIT" . +org-todo-onhold)
          ("HOLD" . +org-todo-onhold)
          ("PROJ" . +org-todo-project)
          ("NO"   . +org-todo-cancel)
          ("KILL" . +org-todo-cancel))))
#+end_src

**** org-agenda
#+begin_src emacs-lisp
(use-feature org-agenda
  :custom
  (org-agenda-tags-column 0)
  (org-agenda-block-separator ?─)
  (org-agenda-time-grid
  '((daily today require-timed)
    (800 1000 1200 1400 1600 1800 2000)
    " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄"))
  (org-agenda-current-time-string
  "⭠ now ─────────────────────────────────────────────────"))
#+end_src

**** org-indent
;; TEMP: This will solve the "Invalid face reference: org-indent [X times]"
;; problem.
#+begin_src emacs-lisp
(use-feature org-indent
  :after org
  :demand t)
#+end_src

**** ox
#+begin_src emacs-lisp
(use-feature ox
  :after org)

(use-feature ox-latex
  :after ox
  :custom
  (org-latex-src-block-backend 'engraved)
  (org-latex-prefer-user-labels t)
  (org-latex-tables-booktabs t)
  ;; Default `minted` options, can be overwritten in file/dir locals
  (org-latex-minted-options
  '(("frame"         "lines")
    ("fontsize"      "\\footnotesize")
    ("tabsize"       "2")
    ("breaklines"    "true")
    ("breakanywhere" "true") ;; break anywhere, no just on spaces
    ("style"         "default")
    ("bgcolor"       "GhostWhite")
    ("linenos"       "true")))
  :config
  ;; (setq org-latex-line-break-safe "\\\\")
  ;; Add this to your config to be able to export with minted:
  ;; (with-eval-after-load 'ox-latex
  ;;   (add-to-list 'org-latex-packages-alist '("" "minted"))
  ;;   (add-to-list 'org-latex-packages-alist '("svgnames" "xcolor"))
  ;;   (setq org-latex-src-block-backend 'minted
  ;;         org-latex-pdf-process '("latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f")))

  ;; Map some org-mode blocks' languages to lexers supported by minted
  ;; you can see supported lexers by running this command in a terminal:
  ;; 'pygmentize -L lexers'
  (dolist (pair '((ipython    "python")
                  (jupyter    "python")
                  (scheme     "scheme")
                  (lisp-data  "lisp")
                  (conf-unix  "unixconfig")
                  (conf-space "unixconfig")
                  (authinfo   "unixconfig")
                  (gdb-script "unixconfig")
                  (conf-toml  "yaml")
                  (conf       "ini")
                  (gitconfig  "ini")
                  (systemd    "ini")))
    (unless (member pair org-latex-minted-langs)
      (add-to-list 'org-latex-minted-langs pair)))

  (cond
  ((executable-find "latexmk")
    (setq
    org-latex-pdf-process
    '("latexmk -c -bibtex-cond1 %f" ; ensure cleaning ".bbl" files
      "latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f")))
  ;; NOTE: Tectonic might have some issues with some documents (sagej + natbib)
  ((executable-find "tectonic")
    (setq
    org-latex-pdf-process
    '("tectonic -X compile --outdir=%o -Z shell-escape -Z continue-on-errors %f")))))

(use-feature ox-koma-letter
  :after ox
  :demand t)

(use-feature ox-odt
  :after ox
  :demand t)

(use-feature ox-beamer
  :after ox
  :demand t)
#+end_src

**** oc
#+begin_src emacs-lisp
(use-feature oc
  :after org
  :demand t
  :custom
  (org-cite-export-processors '((latex biblatex) (t csl)))
  (org-support-shift-select t)
  :config
  (+map-local! :keymaps 'org-mode-map
    "C" #'org-cite-insert))

(use-feature oc-csl
  :after oc
  :demand t)

(use-feature oc-natbib
  :after oc
  :demand t)

(use-feature oc-biblatex
  :after oc
  :demand t)
#+end_src

**** toc-org
#+begin_src emacs-lisp
(use-package toc-org
  :after org
  :hook ((org-mode markdown-mode) . toc-org-mode))
#+end_src
